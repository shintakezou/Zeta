/*
    Zeta CL, OpenCL Chess Engine
    Author: Srdja Matovic <srdja.matovic@googlemail.com>
    Created at: 20-Jan-2011
    Updated at:
    Description: A Chess Engine written in OpenCL, a language suited for GPUs.

    Copyright (C) 2011 Srdja Matovic
    This program is distributed under the GNU General Public License.
    See file COPYING or http://www.gnu.org/licenses/
*/

#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics       : enable
#pragma OPENCL EXTENSION cl_khr_global_int32_extended_atomics   : enable
//#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics        : enable
//#pragma OPENCL EXTENSION cl_khr_byte_addressable_store          : enable

typedef unsigned long   U64;
typedef unsigned int    U32;
typedef signed int      S32;

typedef S32             Score;
typedef U32             Square;
typedef U32             Piece;

typedef U64 Cr;
typedef U64 Move;
typedef U64 Bitboard;
typedef U64 Hash;

typedef struct {
    Move move;
    Score score;
    S32 lock;
    S32 visits;
    S32 child;
    S32 children;
    S32 parent;
}  NodeBlock;


#define WHITE       0
#define BLACK       1

#define ALPHA       0
#define BETA        1

// modes
#define INIT        0
#define SELECTION   1
#define EXPAND      2
#define EVALLEAF    3
#define MOVEUP      4
#define MOVEDOWN    5
#define BACKUPSCORE 6

#define INF 32000
#define MATESCORE 31000
#define MIDGAME 128
#define ENDGAME 0
#define GrainSize 8

#define MAXLEGALMOVES 220

#define FLIPFLOP(square)    ((square^7)^56)
#define FLIP(square)        (square^7)
#define FLOP(square)        (square^56)
#define SwitchSide(som)     ((som == WHITE)? BLACK : WHITE)
#define RelativeRank(som,r) (r^(som*7))

#define PEMPTY  0
#define PAWN    1
#define KNIGHT  2
#define KING    3
#define BISHOP  4
#define ROOK    5
#define QUEEN   6

#define ILL     64

// tuneable search parameter
#define MAXEVASIONS          3                  // 0 to max_depth
#define TERMINATESOFT        1                 // 0 or 1, will finish all searches before exit
#define SMOOTHUCT            0.28             // factor for uct params in select formula
#define PROMOSEARCHEXTENSION 1               // 0 or 1
#define CHECKSEARCHEXTENSION 1              // 0 or 1
#define SINGLEREPLYEXTENSION 1             // 0 or 1
#define CASTLEEXTENSION      1            // 0 or 1
#define SILENTEXTENSION      1           // 0 or 1
#define SKIPMATE             1          // 0 or 1
#define DELTAPRUNING         0         // 0 or 1, unstable
#define ROOTSEARCH           0        // 0 or 1
#define SCOREWEIGHT          0.33    // factor for board score in select formula
#define ZETAPRUNING          0      // 0 or 1


// Zobrist Keys for Hashing
__constant Hash Zobrist[896] = {
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x9D39247E33776D41, 0x2AF7398005AAA5C7, 0x44DB015024623547, 0x9C15F73E62A76AE2,
   0x75834465489C0C89, 0x3290AC3A203001BF, 0x0FBBAD1F61042279, 0xE83A908FF2FB60CA,
   0x0D7E765D58755C10, 0x1A083822CEAFE02D, 0x9605D5F0E25EC3B0, 0xD021FF5CD13A2ED5,
   0x40BDF15D4A672E32, 0x011355146FD56395, 0x5DB4832046F3D9E5, 0x239F8B2D7FF719CC,
   0x05D1A1AE85B49AA1, 0x679F848F6E8FC971, 0x7449BBFF801FED0B, 0x7D11CDB1C3B7ADF0,
   0x82C7709E781EB7CC, 0xF3218F1C9510786C, 0x331478F3AF51BBE6, 0x4BB38DE5E7219443,
   0xAA649C6EBCFD50FC, 0x8DBD98A352AFD40B, 0x87D2074B81D79217, 0x19F3C751D3E92AE1,
   0xB4AB30F062B19ABF, 0x7B0500AC42047AC4, 0xC9452CA81A09D85D, 0x24AA6C514DA27500,
   0x4C9F34427501B447, 0x14A68FD73C910841, 0xA71B9B83461CBD93, 0x03488B95B0F1850F,
   0x637B2B34FF93C040, 0x09D1BC9A3DD90A94, 0x3575668334A1DD3B, 0x735E2B97A4C45A23,
   0x18727070F1BD400B, 0x1FCBACD259BF02E7, 0xD310A7C2CE9B6555, 0xBF983FE0FE5D8244,
   0x9F74D14F7454A824, 0x51EBDC4AB9BA3035, 0x5C82C505DB9AB0FA, 0xFCF7FE8A3430B241,
   0x3253A729B9BA3DDE, 0x8C74C368081B3075, 0xB9BC6C87167C33E7, 0x7EF48F2B83024E20,
   0x11D505D4C351BD7F, 0x6568FCA92C76A243, 0x4DE0B0F40F32A7B8, 0x96D693460CC37E5D,
   0x42E240CB63689F2F, 0x6D2BDCDAE2919661, 0x42880B0236E4D951, 0x5F0F4A5898171BB6,
   0x39F890F579F92F88, 0x93C5B5F47356388B, 0x63DC359D8D231B78, 0xEC16CA8AEA98AD76,
   0x5355F900C2A82DC7, 0x07FB9F855A997142, 0x5093417AA8A7ED5E, 0x7BCBC38DA25A7F3C,
   0x19FC8A768CF4B6D4, 0x637A7780DECFC0D9, 0x8249A47AEE0E41F7, 0x79AD695501E7D1E8,
   0x14ACBAF4777D5776, 0xF145B6BECCDEA195, 0xDABF2AC8201752FC, 0x24C3C94DF9C8D3F6,
   0xBB6E2924F03912EA, 0x0CE26C0B95C980D9, 0xA49CD132BFBF7CC4, 0xE99D662AF4243939,
   0x27E6AD7891165C3F, 0x8535F040B9744FF1, 0x54B3F4FA5F40D873, 0x72B12C32127FED2B,
   0xEE954D3C7B411F47, 0x9A85AC909A24EAA1, 0x70AC4CD9F04F21F5, 0xF9B89D3E99A075C2,
   0x87B3E2B2B5C907B1, 0xA366E5B8C54F48B8, 0xAE4A9346CC3F7CF2, 0x1920C04D47267BBD,
   0x87BF02C6B49E2AE9, 0x092237AC237F3859, 0xFF07F64EF8ED14D0, 0x8DE8DCA9F03CC54E,
   0x9C1633264DB49C89, 0xB3F22C3D0B0B38ED, 0x390E5FB44D01144B, 0x5BFEA5B4712768E9,
   0x1E1032911FA78984, 0x9A74ACB964E78CB3, 0x4F80F7A035DAFB04, 0x6304D09A0B3738C4,
   0x2171E64683023A08, 0x5B9B63EB9CEFF80C, 0x506AACF489889342, 0x1881AFC9A3A701D6,
   0x6503080440750644, 0xDFD395339CDBF4A7, 0xEF927DBCF00C20F2, 0x7B32F7D1E03680EC,
   0xB9FD7620E7316243, 0x05A7E8A57DB91B77, 0xB5889C6E15630A75, 0x4A750A09CE9573F7,
   0xCF464CEC899A2F8A, 0xF538639CE705B824, 0x3C79A0FF5580EF7F, 0xEDE6C87F8477609D,
   0x799E81F05BC93F31, 0x86536B8CF3428A8C, 0x97D7374C60087B73, 0xA246637CFF328532,
   0x043FCAE60CC0EBA0, 0x920E449535DD359E, 0x70EB093B15B290CC, 0x73A1921916591CBD,
   0x56436C9FE1A1AA8D, 0xEFAC4B70633B8F81, 0xBB215798D45DF7AF, 0x45F20042F24F1768,
   0x930F80F4E8EB7462, 0xFF6712FFCFD75EA1, 0xAE623FD67468AA70, 0xDD2C5BC84BC8D8FC,
   0x7EED120D54CF2DD9, 0x22FE545401165F1C, 0xC91800E98FB99929, 0x808BD68E6AC10365,
   0xDEC468145B7605F6, 0x1BEDE3A3AEF53302, 0x43539603D6C55602, 0xAA969B5C691CCB7A,
   0xA87832D392EFEE56, 0x65942C7B3C7E11AE, 0xDED2D633CAD004F6, 0x21F08570F420E565,
   0xB415938D7DA94E3C, 0x91B859E59ECB6350, 0x10CFF333E0ED804A, 0x28AED140BE0BB7DD,
   0xC5CC1D89724FA456, 0x5648F680F11A2741, 0x2D255069F0B7DAB3, 0x9BC5A38EF729ABD4,
   0xEF2F054308F6A2BC, 0xAF2042F5CC5C2858, 0x480412BAB7F5BE2A, 0xAEF3AF4A563DFE43,
   0x19AFE59AE451497F, 0x52593803DFF1E840, 0xF4F076E65F2CE6F0, 0x11379625747D5AF3,
   0xBCE5D2248682C115, 0x9DA4243DE836994F, 0x066F70B33FE09017, 0x4DC4DE189B671A1C,
   0x51039AB7712457C3, 0xC07A3F80C31FB4B4, 0xB46EE9C5E64A6E7C, 0xB3819A42ABE61C87,
   0x21A007933A522A20, 0x2DF16F761598AA4F, 0x763C4A1371B368FD, 0xF793C46702E086A0,
   0xD7288E012AEB8D31, 0xDE336A2A4BC1C44B, 0x0BF692B38D079F23, 0x2C604A7A177326B3,
   0x4850E73E03EB6064, 0xCFC447F1E53C8E1B, 0xB05CA3F564268D99, 0x9AE182C8BC9474E8,
   0xA4FC4BD4FC5558CA, 0xE755178D58FC4E76, 0x69B97DB1A4C03DFE, 0xF9B5B7C4ACC67C96,
   0xFC6A82D64B8655FB, 0x9C684CB6C4D24417, 0x8EC97D2917456ED0, 0x6703DF9D2924E97E,
   0xC547F57E42A7444E, 0x78E37644E7CAD29E, 0xFE9A44E9362F05FA, 0x08BD35CC38336615,
   0x9315E5EB3A129ACE, 0x94061B871E04DF75, 0xDF1D9F9D784BA010, 0x3BBA57B68871B59D,
   0xD2B7ADEEDED1F73F, 0xF7A255D83BC373F8, 0xD7F4F2448C0CEB81, 0xD95BE88CD210FFA7,
   0x336F52F8FF4728E7, 0xA74049DAC312AC71, 0xA2F61BB6E437FDB5, 0x4F2A5CB07F6A35B3,
   0x87D380BDA5BF7859, 0x16B9F7E06C453A21, 0x7BA2484C8A0FD54E, 0xF3A678CAD9A2E38C,
   0x39B0BF7DDE437BA2, 0xFCAF55C1BF8A4424, 0x18FCF680573FA594, 0x4C0563B89F495AC3,
   0x40E087931A00930D, 0x8CFFA9412EB642C1, 0x68CA39053261169F, 0x7A1EE967D27579E2,
   0x9D1D60E5076F5B6F, 0x3810E399B6F65BA2, 0x32095B6D4AB5F9B1, 0x35CAB62109DD038A,
   0xA90B24499FCFAFB1, 0x77A225A07CC2C6BD, 0x513E5E634C70E331, 0x4361C0CA3F692F12,
   0xD941ACA44B20A45B, 0x528F7C8602C5807B, 0x52AB92BEB9613989, 0x9D1DFA2EFC557F73,
   0x722FF175F572C348, 0x1D1260A51107FE97, 0x7A249A57EC0C9BA2, 0x04208FE9E8F7F2D6,
   0x5A110C6058B920A0, 0x0CD9A497658A5698, 0x56FD23C8F9715A4C, 0x284C847B9D887AAE,
   0x04FEABFBBDB619CB, 0x742E1E651C60BA83, 0x9A9632E65904AD3C, 0x881B82A13B51B9E2,
   0x506E6744CD974924, 0xB0183DB56FFC6A79, 0x0ED9B915C66ED37E, 0x5E11E86D5873D484,
   0xF678647E3519AC6E, 0x1B85D488D0F20CC5, 0xDAB9FE6525D89021, 0x0D151D86ADB73615,
   0xA865A54EDCC0F019, 0x93C42566AEF98FFB, 0x99E7AFEABE000731, 0x48CBFF086DDF285A,
   0x7F9B6AF1EBF78BAF, 0x58627E1A149BBA21, 0x2CD16E2ABD791E33, 0xD363EFF5F0977996,
   0x0CE2A38C344A6EED, 0x1A804AADB9CFA741, 0x907F30421D78C5DE, 0x501F65EDB3034D07,
   0x37624AE5A48FA6E9, 0x957BAF61700CFF4E, 0x3A6C27934E31188A, 0xD49503536ABCA345,
   0x088E049589C432E0, 0xF943AEE7FEBF21B8, 0x6C3B8E3E336139D3, 0x364F6FFA464EE52E,
   0xD60F6DCEDC314222, 0x56963B0DCA418FC0, 0x16F50EDF91E513AF, 0xEF1955914B609F93,
   0x565601C0364E3228, 0xECB53939887E8175, 0xBAC7A9A18531294B, 0xB344C470397BBA52,
   0x65D34954DAF3CEBD, 0xB4B81B3FA97511E2, 0xB422061193D6F6A7, 0x071582401C38434D,
   0x7A13F18BBEDC4FF5, 0xBC4097B116C524D2, 0x59B97885E2F2EA28, 0x99170A5DC3115544,
   0x6F423357E7C6A9F9, 0x325928EE6E6F8794, 0xD0E4366228B03343, 0x565C31F7DE89EA27,
   0x30F5611484119414, 0xD873DB391292ED4F, 0x7BD94E1D8E17DEBC, 0xC7D9F16864A76E94,
   0x947AE053EE56E63C, 0xC8C93882F9475F5F, 0x3A9BF55BA91F81CA, 0xD9A11FBB3D9808E4,
   0x0FD22063EDC29FCA, 0xB3F256D8ACA0B0B9, 0xB03031A8B4516E84, 0x35DD37D5871448AF,
   0xE9F6082B05542E4E, 0xEBFAFA33D7254B59, 0x9255ABB50D532280, 0xB9AB4CE57F2D34F3,
   0x693501D628297551, 0xC62C58F97DD949BF, 0xCD454F8F19C5126A, 0xBBE83F4ECC2BDECB,
   0xDC842B7E2819E230, 0xBA89142E007503B8, 0xA3BC941D0A5061CB, 0xE9F6760E32CD8021,
   0x09C7E552BC76492F, 0x852F54934DA55CC9, 0x8107FCCF064FCF56, 0x098954D51FFF6580,
   0x23B70EDB1955C4BF, 0xC330DE426430F69D, 0x4715ED43E8A45C0A, 0xA8D7E4DAB780A08D,
   0x0572B974F03CE0BB, 0xB57D2E985E1419C7, 0xE8D9ECBE2CF3D73F, 0x2FE4B17170E59750,
   0x11317BA87905E790, 0x7FBF21EC8A1F45EC, 0x1725CABFCB045B00, 0x964E915CD5E2B207,
   0x3E2B8BCBF016D66D, 0xBE7444E39328A0AC, 0xF85B2B4FBCDE44B7, 0x49353FEA39BA63B1,
   0x1DD01AAFCD53486A, 0x1FCA8A92FD719F85, 0xFC7C95D827357AFA, 0x18A6A990C8B35EBD,
   0xCCCB7005C6B9C28D, 0x3BDBB92C43B17F26, 0xAA70B5B4F89695A2, 0xE94C39A54A98307F,
   0xB7A0B174CFF6F36E, 0xD4DBA84729AF48AD, 0x2E18BC1AD9704A68, 0x2DE0966DAF2F8B1C,
   0xB9C11D5B1E43A07E, 0x64972D68DEE33360, 0x94628D38D0C20584, 0xDBC0D2B6AB90A559,
   0xD2733C4335C6A72F, 0x7E75D99D94A70F4D, 0x6CED1983376FA72B, 0x97FCAACBF030BC24,
   0x7B77497B32503B12, 0x8547EDDFB81CCB94, 0x79999CDFF70902CB, 0xCFFE1939438E9B24,
   0x829626E3892D95D7, 0x92FAE24291F2B3F1, 0x63E22C147B9C3403, 0xC678B6D860284A1C,
   0x5873888850659AE7, 0x0981DCD296A8736D, 0x9F65789A6509A440, 0x9FF38FED72E9052F,
   0xE479EE5B9930578C, 0xE7F28ECD2D49EECD, 0x56C074A581EA17FE, 0x5544F7D774B14AEF,
   0x7B3F0195FC6F290F, 0x12153635B2C0CF57, 0x7F5126DBBA5E0CA7, 0x7A76956C3EAFB413,
   0x3D5774A11D31AB39, 0x8A1B083821F40CB4, 0x7B4A38E32537DF62, 0x950113646D1D6E03,
   0x4DA8979A0041E8A9, 0x3BC36E078F7515D7, 0x5D0A12F27AD310D1, 0x7F9D1A2E1EBE1327,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0x0               , 0x0               , 0x0               , 0x0,
   0xDA3A361B1C5157B1, 0xDCDD7D20903D0C25, 0x36833336D068F707, 0xCE68341F79893389,
   0xAB9090168DD05F34, 0x43954B3252DC25E5, 0xB438C2B67F98E5E9, 0x10DCD78E3851A492,
   0xDBC27AB5447822BF, 0x9B3CDB65F82CA382, 0xB67B7896167B4C84, 0xBFCED1B0048EAC50,
   0xA9119B60369FFEBD, 0x1FFF7AC80904BF45, 0xAC12FB171817EEE7, 0xAF08DA9177DDA93D,
   0x1B0CAB936E65C744, 0xB559EB1D04E5E932, 0xC37B45B3F8D6F2BA, 0xC3A9DC228CAAC9E9,
   0xF3B8B6675A6507FF, 0x9FC477DE4ED681DA, 0x67378D8ECCEF96CB, 0x6DD856D94D259236,
   0xA319CE15B0B4DB31, 0x073973751F12DD5E, 0x8A8E849EB32781A5, 0xE1925C71285279F5,
   0x74C04BF1790C0EFE, 0x4DDA48153C94938A, 0x9D266D6A1CC0542C, 0x7440FB816508C4FE,
   0x13328503DF48229F, 0xD6BF7BAEE43CAC40, 0x4838D65F6EF6748F, 0x1E152328F3318DEA,
   0x8F8419A348F296BF, 0x72C8834A5957B511, 0xD7A023A73260B45C, 0x94EBC8ABCFB56DAE,
   0x9FC10D0F989993E0, 0xDE68A2355B93CAE6, 0xA44CFE79AE538BBE, 0x9D1D84FCCE371425,
   0x51D2B1AB2DDFB636, 0x2FD7E4B9E72CD38C, 0x65CA5B96B7552210, 0xDD69A0D8AB3B546D,
   0x604D51B25FBF70E2, 0x73AA8A564FB7AC9E, 0x1A8C1E992B941148, 0xAAC40A2703D9BEA0,
   0x764DBEAE7FA4F3A6, 0x1E99B96E70A9BE8B, 0x2C5E9DEB57EF4743, 0x3A938FEE32D29981,
   0x26E6DB8FFDF5ADFE, 0x469356C504EC9F9D, 0xC8763C5B08D1908C, 0x3F6C6AF859D80055,
   0x7F7CC39420A3A545, 0x9BFB227EBDF4C5CE, 0x89039D79D6FC5C5C, 0x8FE88B57305E2AB6,
   0xA09E8C8C35AB96DE, 0xFA7E393983325753, 0xD6B6D0ECC617C699, 0xDFEA21EA9E7557E3,
   0xB67C1FA481680AF8, 0xCA1E3785A9E724E5, 0x1CFC8BED0D681639, 0xD18D8549D140CAEA,
   0x4ED0FE7E9DC91335, 0xE4DBF0634473F5D2, 0x1761F93A44D5AEFE, 0x53898E4C3910DA55,
   0x734DE8181F6EC39A, 0x2680B122BAA28D97, 0x298AF231C85BAFAB, 0x7983EED3740847D5,
   0x66C1A2A1A60CD889, 0x9E17E49642A3E4C1, 0xEDB454E7BADC0805, 0x50B704CAB602C329,
   0x4CC317FB9CDDD023, 0x66B4835D9EAFEA22, 0x219B97E26FFC81BD, 0x261E4E4C0A333A9D,
   0x1FE2CCA76517DB90, 0xD7504DFA8816EDBB, 0xB9571FA04DC089C8, 0x1DDC0325259B27DE,
   0xCF3F4688801EB9AA, 0xF4F5D05C10CAB243, 0x38B6525C21A42B0E, 0x36F60E2BA4FA6800,
   0xEB3593803173E0CE, 0x9C4CD6257C5A3603, 0xAF0C317D32ADAA8A, 0x258E5A80C7204C4B,
   0x8B889D624D44885D, 0xF4D14597E660F855, 0xD4347F66EC8941C3, 0xE699ED85B0DFB40D,
   0x2472F6207C2D0484, 0xC2A1E7B5B459AEB5, 0xAB4F6451CC1D45EC, 0x63767572AE3D6174,
   0xA59E0BD101731A28, 0x116D0016CB948F09, 0x2CF9C8CA052F6E9F, 0x0B090A7560A968E3,
   0xABEEDDB2DDE06FF1, 0x58EFC10B06A2068D, 0xC6E57A78FBD986E0, 0x2EAB8CA63CE802D7,
   0x14A195640116F336, 0x7C0828DD624EC390, 0xD74BBE77E6116AC7, 0x804456AF10F5FB53,
   0xEBE9EA2ADF4321C7, 0x03219A39EE587A30, 0x49787FEF17AF9924, 0xA1E9300CD8520548,
   0x5B45E522E4B1B4EF, 0xB49C3B3995091A36, 0xD4490AD526F14431, 0x12A8F216AF9418C2,
   0x001F837CC7350524, 0x1877B51E57A764D5, 0xA2853B80F17F58EE, 0x993E1DE72D36D310,
   0xB3598080CE64A656, 0x252F59CF0D9F04BB, 0xD23C8E176D113600, 0x1BDA0492E7E4586E,
   0x21E0BD5026C619BF, 0x3B097ADAF088F94E, 0x8D14DEDB30BE846E, 0xF95CFFA23AF5F6F4,
   0x3871700761B3F743, 0xCA672B91E9E4FA16, 0x64C8E531BFF53B55, 0x241260ED4AD1E87D,
   0x106C09B972D2E822, 0x7FBA195410E5CA30, 0x7884D9BC6CB569D8, 0x0647DFEDCD894A29,
   0x63573FF03E224774, 0x4FC8E9560F91B123, 0x1DB956E450275779, 0xB8D91274B9E9D4FB,
   0xA2EBEE47E2FBFCE1, 0xD9F1F30CCD97FB09, 0xEFED53D75FD64E6B, 0x2E6D02C36017F67F,
   0xA9AA4D20DB084E9B, 0xB64BE8D8B25396C1, 0x70CB6AF7C2D5BCF0, 0x98F076A4F7A2322E,
   0xBF84470805E69B5F, 0x94C3251F06F90CF3, 0x3E003E616A6591E9, 0xB925A6CD0421AFF3,
   0x61BDD1307C66E300, 0xBF8D5108E27E0D48, 0x240AB57A8B888B20, 0xFC87614BAF287E07,
   0xEF02CDD06FFDB432, 0xA1082C0466DF6C0A, 0x8215E577001332C8, 0xD39BB9C3A48DB6CF,
   0x2738259634305C14, 0x61CF4F94C97DF93D, 0x1B6BACA2AE4E125B, 0x758F450C88572E0B,
   0x959F587D507A8359, 0xB063E962E045F54D, 0x60E8ED72C0DFF5D1, 0x7B64978555326F9F,
   0xFD080D236DA814BA, 0x8C90FD9B083F4558, 0x106F72FE81E2C590, 0x7976033A39F7D952,
   0xA4EC0132764CA04B, 0x733EA705FAE4FA77, 0xB4D8F77BC3E56167, 0x9E21F4F903B33FD9,
   0x9D765E419FB69F6D, 0xD30C088BA61EA5EF, 0x5D94337FBFAF7F5B, 0x1A4E4822EB4D7A59,
   0x6FFE73E81B637FB3, 0xDDF957BC36D8B9CA, 0x64D0E29EEA8838B3, 0x08DD9BDFD96B9F63,
   0x087E79E5A57D1D13, 0xE328E230E3E2B3FB, 0x1C2559E30F0946BE, 0x720BF5F26F4D2EAA,
   0xB0774D261CC609DB, 0x443F64EC5A371195, 0x4112CF68649A260E, 0xD813F2FAB7F5C5CA,
   0x660D3257380841EE, 0x59AC2C7873F910A3, 0xE846963877671A17, 0x93B633ABFA3469F8,
   0xC0C0F5A60EF4CDCF, 0xCAF21ECD4377B28C, 0x57277707199B8175, 0x506C11B9D90E8B1D,
   0xD83CC2687A19255F, 0x4A29C6465A314CD1, 0xED2DF21216235097, 0xB5635C95FF7296E2,
   0x22AF003AB672E811, 0x52E762596BF68235, 0x9AEBA33AC6ECC6B0, 0x944F6DE09134DFB6,
   0x6C47BEC883A7DE39, 0x6AD047C430A12104, 0xA5B1CFDBA0AB4067, 0x7C45D833AFF07862,
   0x5092EF950A16DA0B, 0x9338E69C052B8E7B, 0x455A4B4CFE30E3F5, 0x6B02E63195AD0CF8,
   0x6B17B224BAD6BF27, 0xD1E0CCD25BB9C169, 0xDE0C89A556B9AE70, 0x50065E535A213CF6,
   0x9C1169FA2777B874, 0x78EDEFD694AF1EED, 0x6DC93D9526A50E68, 0xEE97F453F06791ED,
   0x32AB0EDB696703D3, 0x3A6853C7E70757A7, 0x31865CED6120F37D, 0x67FEF95D92607890,
   0x1F2B1D1F15F6DC9C, 0xB69E38A8965C6B65, 0xAA9119FF184CCCF4, 0xF43C732873F24C13,
   0xFB4A3D794A9A80D2, 0x3550C2321FD6109C, 0x371F77E76BB8417E, 0x6BFA9AAE5EC05779,
   0xCD04F3FF001A4778, 0xE3273522064480CA, 0x9F91508BFFCFC14A, 0x049A7F41061A9E60,
   0xFCB6BE43A9F2FE9B, 0x08DE8A1C7797DA9B, 0x8F9887E6078735A1, 0xB5B4071DBFC73A66,
   0x230E343DFBA08D33, 0x43ED7F5A0FAE657D, 0x3A88A0FBBCB05C63, 0x21874B8B4D2DBC4F,
   0x1BDEA12E35F6A8C9, 0x53C065C6C8E63528, 0xE34A1D250E7A8D6B, 0xD6B04D3B7651DD7E,
   0x5E90277E7CB39E2D, 0x2C046F22062DC67D, 0xB10BB459132D0A26, 0x3FA9DDFB67E2F199,
   0x0E09B88E1914F7AF, 0x10E8B35AF3EEAB37, 0x9EEDECA8E272B933, 0xD4C718BC4AE8AE5F,
   0x81536D601170FC20, 0x91B534F885818A06, 0xEC8177F83F900978, 0x190E714FADA5156E,
   0xB592BF39B0364963, 0x89C350C893AE7DC1, 0xAC042E70F8B383F2, 0xB49B52E587A1EE60,
   0xFB152FE3FF26DA89, 0x3E666E6F69AE2C15, 0x3B544EBE544C19F9, 0xE805A1E290CF2456,
   0x24B33C9D7ED25117, 0xE74733427B72F0C1, 0x0A804D18B7097475, 0x57E3306D881EDB4F,
   0x4AE7D6A36EB5DBCB, 0x2D8D5432157064C8, 0xD1E649DE1E7F268B, 0x8A328A1CEDFE552C,
   0x07A3AEC79624C7DA, 0x84547DDC3E203C94, 0x990A98FD5071D263, 0x1A4FF12616EEFC89,
   0xF6F7FD1431714200, 0x30C05B1BA332F41C, 0x8D2636B81555A786, 0x46C9FEB55D120902,
   0xCCEC0A73B49C9921, 0x4E9D2827355FC492, 0x19EBB029435DCB0F, 0x4659D2B743848A2C,
   0x963EF2C96B33BE31, 0x74F85198B05A2E7D, 0x5A0F544DD2B1FB18, 0x03727073C2E134B1,
   0xC7F6AA2DE59AEA61, 0x352787BAA0D7C22F, 0x9853EAB63B5E0B35, 0xABBDCDD7ED5C0860,
   0xCF05DAF5AC8D77B0, 0x49CAD48CEBF4A71E, 0x7A4C10EC2158C4A6, 0xD9E92AA246BF719E,
   0x13AE978D09FE5557, 0x730499AF921549FF, 0x4E4B705B92903BA4, 0xFF577222C14F0A3A,
   0x55B6344CF97AAFAE, 0xB862225B055B6960, 0xCAC09AFBDDD2CDB4, 0xDAF8E9829FE96B5F,
   0xB5FDFC5D3132C498, 0x310CB380DB6F7503, 0xE87FBB46217A360E, 0x2102AE466EBB1148,
   0xF8549E1A3AA5E00D, 0x07A69AFDCC42261A, 0xC4C118BFE78FEAAE, 0xF9F4892ED96BD438,
   0x1AF3DBE25D8F45DA, 0xF5B4B0B0D2DEEEB4, 0x962ACEEFA82E1C84, 0x046E3ECAAF453CE9,
   0xF05D129681949A4C, 0x964781CE734B3C84, 0x9C2ED44081CE5FBD, 0x522E23F3925E319E,
   0x177E00F9FC32F791, 0x2BC60A63A6F3B3F2, 0x222BBFAE61725606, 0x486289DDCC3D6780,
   0x7DC7785B8EFDFC80, 0x8AF38731C02BA980, 0x1FAB64EA29A2DDF7, 0xE4D9429322CD065A,
   0x9DA058C67844F20C, 0x24C0E332B70019B0, 0x233003B5A6CFE6AD, 0xD586BD01C5C217F6,
   0x5E5637885F29BC2B, 0x7EBA726D8C94094B, 0x0A56A5F0BFE39272, 0xD79476A84EE20D06,
   0x9E4C1269BAA4BF37, 0x17EFEE45B0DEE640, 0x1D95B0A5FCF90BC6, 0x93CBE0B699C2585D,
   0x65FA4F227A2B6D79, 0xD5F9E858292504D5, 0xC2B5A03F71471A6F, 0x59300222B4561E00,
   0xCE2F8642CA0712DC, 0x7CA9723FBB2E8988, 0x2785338347F2BA08, 0xC61BB3A141E50E8C,
   0x150F361DAB9DEC26, 0x9F6A419D382595F4, 0x64A53DC924FE7AC9, 0x142DE49FFF7A7C3D,
   0x0C335248857FA9E7, 0x0A9C32D5EAE45305, 0xE6C42178C4BBB92E, 0x71F1CE2490D20B07,
   0xF1BCC3D275AFE51A, 0xE728E8C83C334074, 0x96FBF83A12884624, 0x81A1549FD6573DA5,
   0x5FA7867CAF35E149, 0x56986E2EF3ED091B, 0x917F1DD5F8886C61, 0xD20D8C88C8FFE65F
};



// Magic Bitboard Move gen stuff
__constant int BitTable[64] = {
  0, 1, 2, 7, 3, 13, 8, 19, 4, 25, 14, 28, 9, 34, 20, 40, 5, 17, 26, 38, 15,
  46, 29, 48, 10, 31, 35, 54, 21, 50, 41, 57, 63, 6, 12, 18, 24, 27, 33, 39,
  16, 37, 45, 47, 30, 53, 49, 56, 62, 11, 23, 32, 36, 44, 52, 55, 61, 22, 43,
  51, 60, 42, 59, 58
};

__constant U64 BMult[64] = {
  0x440049104032280, 0x1021023c82008040, 0x404040082000048,
  0x48c4440084048090, 0x2801104026490000, 0x4100880442040800,
  0x181011002e06040, 0x9101004104200e00, 0x1240848848310401,
  0x2000142828050024, 0x1004024d5000, 0x102044400800200,
  0x8108108820112000, 0xa880818210c00046, 0x4008008801082000,
  0x60882404049400, 0x104402004240810, 0xa002084250200,
  0x100b0880801100, 0x4080201220101, 0x44008080a00000,
  0x202200842000, 0x5006004882d00808, 0x200045080802,
  0x86100020200601, 0xa802080a20112c02, 0x80411218080900,
  0x200a0880080a0, 0x9a01010000104000, 0x28008003100080,
  0x211021004480417, 0x401004188220806, 0x825051400c2006,
  0x140c0210943000, 0x242800300080, 0xc2208120080200,
  0x2430008200002200, 0x1010100112008040, 0x8141050100020842,
  0x822081014405, 0x800c049e40400804, 0x4a0404028a000820,
  0x22060201041200, 0x360904200840801, 0x881a08208800400,
  0x60202c00400420, 0x1204440086061400, 0x8184042804040,
  0x64040315300400, 0xc01008801090a00, 0x808010401140c00,
  0x4004830c2020040, 0x80005002020054, 0x40000c14481a0490,
  0x10500101042048, 0x1010100200424000, 0x640901901040,
  0xa0201014840, 0x840082aa011002, 0x10010840084240a,
  0x420400810420608, 0x8d40230408102100, 0x4a00200612222409,
  0xa08520292120600
};

__constant U64 RMult[64] = {
  0xa8002c000108020, 0x4440200140003000, 0x8080200010011880,
  0x380180080141000, 0x1a00060008211044, 0x410001000a0c0008,
  0x9500060004008100, 0x100024284a20700, 0x802140008000,
  0x80c01002a00840, 0x402004282011020, 0x9862000820420050,
  0x1001448011100, 0x6432800200800400, 0x40100010002000c,
  0x2800d0010c080, 0x90c0008000803042, 0x4010004000200041,
  0x3010010200040, 0xa40828028001000, 0x123010008000430,
  0x24008004020080, 0x60040001104802, 0x582200028400d1,
  0x4000802080044000, 0x408208200420308, 0x610038080102000,
  0x3601000900100020, 0x80080040180, 0xc2020080040080,
  0x80084400100102, 0x4022408200014401, 0x40052040800082,
  0xb08200280804000, 0x8a80a008801000, 0x4000480080801000,
  0x911808800801401, 0x822a003002001894, 0x401068091400108a,
  0x4a10a00004c, 0x2000800640008024, 0x1486408102020020,
  0x100a000d50041, 0x810050020b0020, 0x204000800808004,
  0x20048100a000c, 0x112000831020004, 0x9000040810002,
  0x440490200208200, 0x8910401000200040, 0x6404200050008480,
  0x4b824a2010010100, 0x4080801810c0080, 0x400802a0080,
  0x8224080110026400, 0x40002c4104088200, 0x1002100104a0282,
  0x1208400811048021, 0x3201014a40d02001, 0x5100019200501,
  0x101000208001005, 0x2008450080702, 0x1002080301d00c,
  0x410201ce5c030092
};

__constant int BShift[64] = {
  58, 59, 59, 59, 59, 59, 59, 58, 59, 59, 59, 59, 59, 59, 59, 59,
  59, 59, 57, 57, 57, 57, 59, 59, 59, 59, 57, 55, 55, 57, 59, 59,
  59, 59, 57, 55, 55, 57, 59, 59, 59, 59, 57, 57, 57, 57, 59, 59,
  59, 59, 59, 59, 59, 59, 59, 59, 58, 59, 59, 59, 59, 59, 59, 58
};

__constant int RShift[64] = {
  52, 53, 53, 53, 53, 53, 53, 52, 53, 54, 54, 54, 54, 54, 54, 53,
  53, 54, 54, 54, 54, 54, 54, 53, 53, 54, 54, 54, 54, 54, 54, 53,
  53, 54, 54, 54, 54, 54, 54, 53, 53, 54, 54, 54, 54, 54, 54, 53,
  53, 54, 54, 54, 54, 54, 54, 53, 52, 53, 53, 53, 53, 53, 53, 52
};


__constant Bitboard RMask[64] = 
{
0x101010101017e,0x202020202027c,0x404040404047a,0x8080808080876,0x1010101010106e,0x2020202020205e,0x4040404040403e,0x8080808080807e,0x1010101017e00,0x2020202027c00,0x4040404047a00,0x8080808087600,0x10101010106e00,0x20202020205e00,0x40404040403e00,0x80808080807e00,0x10101017e0100,0x20202027c0200,0x40404047a0400,0x8080808760800,0x101010106e1000,0x202020205e2000,0x404040403e4000,0x808080807e8000,0x101017e010100,0x202027c020200,0x404047a040400,0x8080876080800,0x1010106e101000,0x2020205e202000,0x4040403e404000,0x8080807e808000,0x1017e01010100,0x2027c02020200,0x4047a04040400,0x8087608080800,0x10106e10101000,0x20205e20202000,0x40403e40404000,0x80807e80808000,0x17e0101010100,0x27c0202020200,0x47a0404040400,0x8760808080800,0x106e1010101000,0x205e2020202000,0x403e4040404000,0x807e8080808000,0x7e010101010100,0x7c020202020200,0x7a040404040400,0x76080808080800,0x6e101010101000,0x5e202020202000,0x3e404040404000,0x7e808080808000,0x7e01010101010100,0x7c02020202020200,0x7a04040404040400,0x7608080808080800,0x6e10101010101000,0x5e20202020202000,0x3e40404040404000,0x7e80808080808000
};

__constant Bitboard BMask[64] = 
{
0x40201008040200,0x402010080400,0x4020100a00,0x40221400,0x2442800,0x204085000,0x20408102000,0x2040810204000,0x20100804020000,0x40201008040000,0x4020100a0000,0x4022140000,0x244280000,0x20408500000,0x2040810200000,0x4081020400000,0x10080402000200,0x20100804000400,0x4020100a000a00,0x402214001400,0x24428002800,0x2040850005000,0x4081020002000,0x8102040004000,0x8040200020400,0x10080400040800,0x20100a000a1000,0x40221400142200,0x2442800284400,0x4085000500800,0x8102000201000,0x10204000402000,0x4020002040800,0x8040004081000,0x100a000a102000,0x22140014224000,0x44280028440200,0x8500050080400,0x10200020100800,0x20400040201000,0x2000204081000,0x4000408102000,0xa000a10204000,0x14001422400000,0x28002844020000,0x50005008040200,0x20002010080400,0x40004020100800,0x20408102000,0x40810204000,0xa1020400000,0x142240000000,0x284402000000,0x500804020000,0x201008040200,0x402010080400,0x2040810204000,0x4081020400000,0xa102040000000,0x14224000000000,0x28440200000000,0x50080402000000,0x20100804020000,0x40201008040200
};

__constant int RAttackIndex[64] = 
{
0x0,0x1000,0x1800,0x2000,0x2800,0x3000,0x3800,0x4000,0x5000,0x5800,0x5c00,0x6000,0x6400,0x6800,0x6c00,0x7000,0x7800,0x8000,0x8400,0x8800,0x8c00,0x9000,0x9400,0x9800,0xa000,0xa800,0xac00,0xb000,0xb400,0xb800,0xbc00,0xc000,0xc800,0xd000,0xd400,0xd800,0xdc00,0xe000,0xe400,0xe800,0xf000,0xf800,0xfc00,0x10000,0x10400,0x10800,0x10c00,0x11000,0x11800,0x12000,0x12400,0x12800,0x12c00,0x13000,0x13400,0x13800,0x14000,0x15000,0x15800,0x16000,0x16800,0x17000,0x17800,0x18000
};

__constant int BAttackIndex[64] = 
{
0x0,0x40,0x60,0x80,0xa0,0xc0,0xe0,0x100,0x140,0x160,0x180,0x1a0,0x1c0,0x1e0,0x200,0x220,0x240,0x260,0x280,0x300,0x380,0x400,0x480,0x4a0,0x4c0,0x4e0,0x500,0x580,0x780,0x980,0xa00,0xa20,0xa40,0xa60,0xa80,0xb00,0xd00,0xf00,0xf80,0xfa0,0xfc0,0xfe0,0x1000,0x1080,0x1100,0x1180,0x1200,0x1220,0x1240,0x1260,0x1280,0x12a0,0x12c0,0x12e0,0x1300,0x1320,0x1340,0x1380,0x13a0,0x13c0,0x13e0,0x1400,0x1420,0x1440
};


__constant Bitboard SetMaskBB[65] = 
{
0x1 , 0x2 , 0x4 , 0x8 , 0x10 , 0x20 , 0x40 , 0x80 , 0x100 , 0x200 , 0x400 , 0x800 , 0x1000 , 0x2000 , 0x4000 , 0x8000 , 0x10000 , 0x20000 , 0x40000 , 0x80000 , 0x100000 , 0x200000 , 0x400000 , 0x800000 , 0x1000000 , 0x2000000 , 0x4000000 , 0x8000000 , 0x10000000 , 0x20000000 , 0x40000000 , 0x80000000 , 0x100000000 , 0x200000000 , 0x400000000 , 0x800000000 , 0x1000000000 , 0x2000000000 , 0x4000000000 , 0x8000000000 , 0x10000000000 , 0x20000000000 , 0x40000000000 , 0x80000000000 , 0x100000000000 , 0x200000000000 , 0x400000000000 , 0x800000000000 , 0x1000000000000 , 0x2000000000000 , 0x4000000000000 , 0x8000000000000 , 0x10000000000000 , 0x20000000000000 , 0x40000000000000 , 0x80000000000000 , 0x100000000000000 , 0x200000000000000 , 0x400000000000000 , 0x800000000000000 , 0x1000000000000000 , 0x2000000000000000 , 0x4000000000000000 , 0x8000000000000000,0x0000000000000000 
};

__constant Bitboard ClearMaskBB[65] = 
{
0xfffffffffffffffe , 0xfffffffffffffffd , 0xfffffffffffffffb , 0xfffffffffffffff7 , 0xffffffffffffffef , 0xffffffffffffffdf , 0xffffffffffffffbf , 0xffffffffffffff7f , 0xfffffffffffffeff , 0xfffffffffffffdff , 0xfffffffffffffbff , 0xfffffffffffff7ff , 0xffffffffffffefff , 0xffffffffffffdfff , 0xffffffffffffbfff , 0xffffffffffff7fff , 0xfffffffffffeffff , 0xfffffffffffdffff , 0xfffffffffffbffff , 0xfffffffffff7ffff , 0xffffffffffefffff , 0xffffffffffdfffff , 0xffffffffffbfffff , 0xffffffffff7fffff , 0xfffffffffeffffff , 0xfffffffffdffffff , 0xfffffffffbffffff , 0xfffffffff7ffffff , 0xffffffffefffffff , 0xffffffffdfffffff , 0xffffffffbfffffff , 0xffffffff7fffffff , 0xfffffffeffffffff , 0xfffffffdffffffff , 0xfffffffbffffffff , 0xfffffff7ffffffff , 0xffffffefffffffff , 0xffffffdfffffffff , 0xffffffbfffffffff , 0xffffff7fffffffff , 0xfffffeffffffffff , 0xfffffdffffffffff , 0xfffffbffffffffff , 0xfffff7ffffffffff , 0xffffefffffffffff , 0xffffdfffffffffff , 0xffffbfffffffffff , 0xffff7fffffffffff , 0xfffeffffffffffff , 0xfffdffffffffffff , 0xfffbffffffffffff , 0xfff7ffffffffffff , 0xffefffffffffffff , 0xffdfffffffffffff , 0xffbfffffffffffff , 0xff7fffffffffffff , 0xfeffffffffffffff , 0xfdffffffffffffff , 0xfbffffffffffffff , 0xf7ffffffffffffff , 0xefffffffffffffff , 0xdfffffffffffffff , 0xbfffffffffffffff , 0x7fffffffffffffff, 0xffffffffffffffff
};


// Attack Tables
__constant Bitboard AttackTables[2*7*64] = 
{
0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x20400,0x50800,0xa1100,0x142200,0x284400,0x508800,0xa01000,0x402000,0x2040004,0x5080008,0xa110011,0x14220022,0x28440044,0x50880088,0xa0100010,0x40200020,0x204000402,0x508000805,0xa1100110a,0x1422002214,0x2844004428,0x5088008850,0xa0100010a0,0x4020002040,0x20400040200,0x50800080500,0xa1100110a00,0x142200221400,0x284400442800,0x508800885000,0xa0100010a000,0x402000204000,0x2040004020000,0x5080008050000,0xa1100110a0000,0x14220022140000,0x28440044280000,0x50880088500000,0xa0100010a00000,0x40200020400000,0x204000402000000,0x508000805000000,0xa1100110a000000,0x1422002214000000,0x2844004428000000,0x5088008850000000,0xa0100010a0000000,0x4020002040000000,0x400040200000000,0x800080500000000,0x1100110a00000000,0x2200221400000000,0x4400442800000000,0x8800885000000000,0x100010a000000000,0x2000204000000000,0x4020000000000,0x8050000000000,0x110a0000000000,0x22140000000000,0x44280000000000,0x88500000000000,0x10a00000000000,0x20400000000000,
0x302,0x705,0xe0a,0x1c14,0x3828,0x7050,0xe0a0,0xc040,0x30203,0x70507,0xe0a0e,0x1c141c,0x382838,0x705070,0xe0a0e0,0xc040c0,0x3020300,0x7050700,0xe0a0e00,0x1c141c00,0x38283800,0x70507000,0xe0a0e000,0xc040c000,0x302030000,0x705070000,0xe0a0e0000,0x1c141c0000,0x3828380000,0x7050700000,0xe0a0e00000,0xc040c00000,0x30203000000,0x70507000000,0xe0a0e000000,0x1c141c000000,0x382838000000,0x705070000000,0xe0a0e0000000,0xc040c0000000,0x3020300000000,0x7050700000000,0xe0a0e00000000,0x1c141c00000000,0x38283800000000,0x70507000000000,0xe0a0e000000000,0xc040c000000000,0x302030000000000,0x705070000000000,0xe0a0e0000000000,0x1c141c0000000000,0x3828380000000000,0x7050700000000000,0xe0a0e00000000000,0xc040c00000000000,0x203000000000000,0x507000000000000,0xa0e000000000000,0x141c000000000000,0x2838000000000000,0x5070000000000000,0xa0e0000000000000,0x40c0000000000000,
0x8040201008040200,0x80402010080500,0x804020110a00,0x8041221400,0x182442800,0x10204885000,0x102040810a000,0x102040810204000,0x4020100804020002,0x8040201008050005,0x804020110a000a,0x804122140014,0x18244280028,0x1020488500050,0x102040810a000a0,0x204081020400040,0x2010080402000204,0x4020100805000508,0x804020110a000a11,0x80412214001422,0x1824428002844,0x102048850005088,0x2040810a000a010,0x408102040004020,0x1008040200020408,0x2010080500050810,0x4020110a000a1120,0x8041221400142241,0x182442800284482,0x204885000508804,0x40810a000a01008,0x810204000402010,0x804020002040810,0x1008050005081020,0x20110a000a112040,0x4122140014224180,0x8244280028448201,0x488500050880402,0x810a000a0100804,0x1020400040201008,0x402000204081020,0x805000508102040,0x110a000a11204080,0x2214001422418000,0x4428002844820100,0x8850005088040201,0x10a000a010080402,0x2040004020100804,0x200020408102040,0x500050810204080,0xa000a1120408000,0x1400142241800000,0x2800284482010000,0x5000508804020100,0xa000a01008040201,0x4000402010080402,0x2040810204080,0x5081020408000,0xa112040800000,0x14224180000000,0x28448201000000,0x50880402010000,0xa0100804020100,0x40201008040201,
0x1010101010101fe,0x2020202020202fd,0x4040404040404fb,0x8080808080808f7,0x10101010101010ef,0x20202020202020df,0x40404040404040bf,0x808080808080807f,0x10101010101fe01,0x20202020202fd02,0x40404040404fb04,0x80808080808f708,0x101010101010ef10,0x202020202020df20,0x404040404040bf40,0x8080808080807f80,0x101010101fe0101,0x202020202fd0202,0x404040404fb0404,0x808080808f70808,0x1010101010ef1010,0x2020202020df2020,0x4040404040bf4040,0x80808080807f8080,0x1010101fe010101,0x2020202fd020202,0x4040404fb040404,0x8080808f7080808,0x10101010ef101010,0x20202020df202020,0x40404040bf404040,0x808080807f808080,0x10101fe01010101,0x20202fd02020202,0x40404fb04040404,0x80808f708080808,0x101010ef10101010,0x202020df20202020,0x404040bf40404040,0x8080807f80808080,0x101fe0101010101,0x202fd0202020202,0x404fb0404040404,0x808f70808080808,0x1010ef1010101010,0x2020df2020202020,0x4040bf4040404040,0x80807f8080808080,0x1fe010101010101,0x2fd020202020202,0x4fb040404040404,0x8f7080808080808,0x10ef101010101010,0x20df202020202020,0x40bf404040404040,0x807f808080808080,0xfe01010101010101,0xfd02020202020202,0xfb04040404040404,0xf708080808080808,0xef10101010101010,0xdf20202020202020,0xbf40404040404040,0x7f80808080808080,
0x81412111090503fe,0x2824222120a07fd,0x404844424150efb,0x8080888492a1cf7,0x10101011925438ef,0x2020212224a870df,0x404142444850e0bf,0x8182848890a0c07f,0x412111090503fe03,0x824222120a07fd07,0x4844424150efb0e,0x80888492a1cf71c,0x101011925438ef38,0x20212224a870df70,0x4142444850e0bfe0,0x82848890a0c07fc0,0x2111090503fe0305,0x4222120a07fd070a,0x844424150efb0e15,0x888492a1cf71c2a,0x1011925438ef3854,0x212224a870df70a8,0x42444850e0bfe050,0x848890a0c07fc0a0,0x11090503fe030509,0x22120a07fd070a12,0x4424150efb0e1524,0x88492a1cf71c2a49,0x11925438ef385492,0x2224a870df70a824,0x444850e0bfe05048,0x8890a0c07fc0a090,0x90503fe03050911,0x120a07fd070a1222,0x24150efb0e152444,0x492a1cf71c2a4988,0x925438ef38549211,0x24a870df70a82422,0x4850e0bfe0504844,0x90a0c07fc0a09088,0x503fe0305091121,0xa07fd070a122242,0x150efb0e15244484,0x2a1cf71c2a498808,0x5438ef3854921110,0xa870df70a8242221,0x50e0bfe050484442,0xa0c07fc0a0908884,0x3fe030509112141,0x7fd070a12224282,0xefb0e1524448404,0x1cf71c2a49880808,0x38ef385492111010,0x70df70a824222120,0xe0bfe05048444241,0xc07fc0a090888482,0xfe03050911214181,0xfd070a1222428202,0xfb0e152444840404,0xf71c2a4988080808,0xef38549211101010,0xdf70a82422212020,0xbfe0504844424140,0x7fc0a09088848281,
0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x20400,0x50800,0xa1100,0x142200,0x284400,0x508800,0xa01000,0x402000,0x2040004,0x5080008,0xa110011,0x14220022,0x28440044,0x50880088,0xa0100010,0x40200020,0x204000402,0x508000805,0xa1100110a,0x1422002214,0x2844004428,0x5088008850,0xa0100010a0,0x4020002040,0x20400040200,0x50800080500,0xa1100110a00,0x142200221400,0x284400442800,0x508800885000,0xa0100010a000,0x402000204000,0x2040004020000,0x5080008050000,0xa1100110a0000,0x14220022140000,0x28440044280000,0x50880088500000,0xa0100010a00000,0x40200020400000,0x204000402000000,0x508000805000000,0xa1100110a000000,0x1422002214000000,0x2844004428000000,0x5088008850000000,0xa0100010a0000000,0x4020002040000000,0x400040200000000,0x800080500000000,0x1100110a00000000,0x2200221400000000,0x4400442800000000,0x8800885000000000,0x100010a000000000,0x2000204000000000,0x4020000000000,0x8050000000000,0x110a0000000000,0x22140000000000,0x44280000000000,0x88500000000000,0x10a00000000000,0x20400000000000,
0x302,0x705,0xe0a,0x1c14,0x3828,0x7050,0xe0a0,0xc040,0x30203,0x70507,0xe0a0e,0x1c141c,0x382838,0x705070,0xe0a0e0,0xc040c0,0x3020300,0x7050700,0xe0a0e00,0x1c141c00,0x38283800,0x70507000,0xe0a0e000,0xc040c000,0x302030000,0x705070000,0xe0a0e0000,0x1c141c0000,0x3828380000,0x7050700000,0xe0a0e00000,0xc040c00000,0x30203000000,0x70507000000,0xe0a0e000000,0x1c141c000000,0x382838000000,0x705070000000,0xe0a0e0000000,0xc040c0000000,0x3020300000000,0x7050700000000,0xe0a0e00000000,0x1c141c00000000,0x38283800000000,0x70507000000000,0xe0a0e000000000,0xc040c000000000,0x302030000000000,0x705070000000000,0xe0a0e0000000000,0x1c141c0000000000,0x3828380000000000,0x7050700000000000,0xe0a0e00000000000,0xc040c00000000000,0x203000000000000,0x507000000000000,0xa0e000000000000,0x141c000000000000,0x2838000000000000,0x5070000000000000,0xa0e0000000000000,0x40c0000000000000,
0x8040201008040200,0x80402010080500,0x804020110a00,0x8041221400,0x182442800,0x10204885000,0x102040810a000,0x102040810204000,0x4020100804020002,0x8040201008050005,0x804020110a000a,0x804122140014,0x18244280028,0x1020488500050,0x102040810a000a0,0x204081020400040,0x2010080402000204,0x4020100805000508,0x804020110a000a11,0x80412214001422,0x1824428002844,0x102048850005088,0x2040810a000a010,0x408102040004020,0x1008040200020408,0x2010080500050810,0x4020110a000a1120,0x8041221400142241,0x182442800284482,0x204885000508804,0x40810a000a01008,0x810204000402010,0x804020002040810,0x1008050005081020,0x20110a000a112040,0x4122140014224180,0x8244280028448201,0x488500050880402,0x810a000a0100804,0x1020400040201008,0x402000204081020,0x805000508102040,0x110a000a11204080,0x2214001422418000,0x4428002844820100,0x8850005088040201,0x10a000a010080402,0x2040004020100804,0x200020408102040,0x500050810204080,0xa000a1120408000,0x1400142241800000,0x2800284482010000,0x5000508804020100,0xa000a01008040201,0x4000402010080402,0x2040810204080,0x5081020408000,0xa112040800000,0x14224180000000,0x28448201000000,0x50880402010000,0xa0100804020100,0x40201008040201,
0x1010101010101fe,0x2020202020202fd,0x4040404040404fb,0x8080808080808f7,0x10101010101010ef,0x20202020202020df,0x40404040404040bf,0x808080808080807f,0x10101010101fe01,0x20202020202fd02,0x40404040404fb04,0x80808080808f708,0x101010101010ef10,0x202020202020df20,0x404040404040bf40,0x8080808080807f80,0x101010101fe0101,0x202020202fd0202,0x404040404fb0404,0x808080808f70808,0x1010101010ef1010,0x2020202020df2020,0x4040404040bf4040,0x80808080807f8080,0x1010101fe010101,0x2020202fd020202,0x4040404fb040404,0x8080808f7080808,0x10101010ef101010,0x20202020df202020,0x40404040bf404040,0x808080807f808080,0x10101fe01010101,0x20202fd02020202,0x40404fb04040404,0x80808f708080808,0x101010ef10101010,0x202020df20202020,0x404040bf40404040,0x8080807f80808080,0x101fe0101010101,0x202fd0202020202,0x404fb0404040404,0x808f70808080808,0x1010ef1010101010,0x2020df2020202020,0x4040bf4040404040,0x80807f8080808080,0x1fe010101010101,0x2fd020202020202,0x4fb040404040404,0x8f7080808080808,0x10ef101010101010,0x20df202020202020,0x40bf404040404040,0x807f808080808080,0xfe01010101010101,0xfd02020202020202,0xfb04040404040404,0xf708080808080808,0xef10101010101010,0xdf20202020202020,0xbf40404040404040,0x7f80808080808080,
0x81412111090503fe,0x2824222120a07fd,0x404844424150efb,0x8080888492a1cf7,0x10101011925438ef,0x2020212224a870df,0x404142444850e0bf,0x8182848890a0c07f,0x412111090503fe03,0x824222120a07fd07,0x4844424150efb0e,0x80888492a1cf71c,0x101011925438ef38,0x20212224a870df70,0x4142444850e0bfe0,0x82848890a0c07fc0,0x2111090503fe0305,0x4222120a07fd070a,0x844424150efb0e15,0x888492a1cf71c2a,0x1011925438ef3854,0x212224a870df70a8,0x42444850e0bfe050,0x848890a0c07fc0a0,0x11090503fe030509,0x22120a07fd070a12,0x4424150efb0e1524,0x88492a1cf71c2a49,0x11925438ef385492,0x2224a870df70a824,0x444850e0bfe05048,0x8890a0c07fc0a090,0x90503fe03050911,0x120a07fd070a1222,0x24150efb0e152444,0x492a1cf71c2a4988,0x925438ef38549211,0x24a870df70a82422,0x4850e0bfe0504844,0x90a0c07fc0a09088,0x503fe0305091121,0xa07fd070a122242,0x150efb0e15244484,0x2a1cf71c2a498808,0x5438ef3854921110,0xa870df70a8242221,0x50e0bfe050484442,0xa0c07fc0a0908884,0x3fe030509112141,0x7fd070a12224282,0xefb0e1524448404,0x1cf71c2a49880808,0x38ef385492111010,0x70df70a824222120,0xe0bfe05048444241,0xc07fc0a090888482,0xfe03050911214181,0xfd070a1222428202,0xfb0e152444840404,0xf71c2a4988080808,0xef38549211101010,0xdf70a82422212020,0xbfe0504844424140,0x7fc0a09088848281
};

__constant Bitboard AttackTablesTo[2*7*64] = 
{
0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x5,0xa,0x14,0x28,0x50,0xa0,0x40,0x200,0x500,0xa00,0x1400,0x2800,0x5000,0xa000,0x4000,0x20000,0x50000,0xa0000,0x140000,0x280000,0x500000,0xa00000,0x400000,0x2000000,0x5000000,0xa000000,0x14000000,0x28000000,0x50000000,0xa0000000,0x40000000,0x200000000,0x500000000,0xa00000000,0x1400000000,0x2800000000,0x5000000000,0xa000000000,0x4000000000,0x20000000000,0x50000000000,0xa0000000000,0x140000000000,0x280000000000,0x500000000000,0xa00000000000,0x400000000000,0x2000000000000,0x5000000000000,0xa000000000000,0x14000000000000,0x28000000000000,0x50000000000000,0xa0000000000000,0x40000000000000,
0x20400,0x50800,0xa1100,0x142200,0x284400,0x508800,0xa01000,0x402000,0x2040004,0x5080008,0xa110011,0x14220022,0x28440044,0x50880088,0xa0100010,0x40200020,0x204000402,0x508000805,0xa1100110a,0x1422002214,0x2844004428,0x5088008850,0xa0100010a0,0x4020002040,0x20400040200,0x50800080500,0xa1100110a00,0x142200221400,0x284400442800,0x508800885000,0xa0100010a000,0x402000204000,0x2040004020000,0x5080008050000,0xa1100110a0000,0x14220022140000,0x28440044280000,0x50880088500000,0xa0100010a00000,0x40200020400000,0x204000402000000,0x508000805000000,0xa1100110a000000,0x1422002214000000,0x2844004428000000,0x5088008850000000,0xa0100010a0000000,0x4020002040000000,0x400040200000000,0x800080500000000,0x1100110a00000000,0x2200221400000000,0x4400442800000000,0x8800885000000000,0x100010a000000000,0x2000204000000000,0x4020000000000,0x8050000000000,0x110a0000000000,0x22140000000000,0x44280000000000,0x88500000000000,0x10a00000000000,0x20400000000000,
0x302,0x705,0xe0a,0x1c14,0x3828,0x7050,0xe0a0,0xc040,0x30203,0x70507,0xe0a0e,0x1c141c,0x382838,0x705070,0xe0a0e0,0xc040c0,0x3020300,0x7050700,0xe0a0e00,0x1c141c00,0x38283800,0x70507000,0xe0a0e000,0xc040c000,0x302030000,0x705070000,0xe0a0e0000,0x1c141c0000,0x3828380000,0x7050700000,0xe0a0e00000,0xc040c00000,0x30203000000,0x70507000000,0xe0a0e000000,0x1c141c000000,0x382838000000,0x705070000000,0xe0a0e0000000,0xc040c0000000,0x3020300000000,0x7050700000000,0xe0a0e00000000,0x1c141c00000000,0x38283800000000,0x70507000000000,0xe0a0e000000000,0xc040c000000000,0x302030000000000,0x705070000000000,0xe0a0e0000000000,0x1c141c0000000000,0x3828380000000000,0x7050700000000000,0xe0a0e00000000000,0xc040c00000000000,0x203000000000000,0x507000000000000,0xa0e000000000000,0x141c000000000000,0x2838000000000000,0x5070000000000000,0xa0e0000000000000,0x40c0000000000000,
0x8040201008040200,0x80402010080500,0x804020110a00,0x8041221400,0x182442800,0x10204885000,0x102040810a000,0x102040810204000,0x4020100804020002,0x8040201008050005,0x804020110a000a,0x804122140014,0x18244280028,0x1020488500050,0x102040810a000a0,0x204081020400040,0x2010080402000204,0x4020100805000508,0x804020110a000a11,0x80412214001422,0x1824428002844,0x102048850005088,0x2040810a000a010,0x408102040004020,0x1008040200020408,0x2010080500050810,0x4020110a000a1120,0x8041221400142241,0x182442800284482,0x204885000508804,0x40810a000a01008,0x810204000402010,0x804020002040810,0x1008050005081020,0x20110a000a112040,0x4122140014224180,0x8244280028448201,0x488500050880402,0x810a000a0100804,0x1020400040201008,0x402000204081020,0x805000508102040,0x110a000a11204080,0x2214001422418000,0x4428002844820100,0x8850005088040201,0x10a000a010080402,0x2040004020100804,0x200020408102040,0x500050810204080,0xa000a1120408000,0x1400142241800000,0x2800284482010000,0x5000508804020100,0xa000a01008040201,0x4000402010080402,0x2040810204080,0x5081020408000,0xa112040800000,0x14224180000000,0x28448201000000,0x50880402010000,0xa0100804020100,0x40201008040201,
0x1010101010101fe,0x2020202020202fd,0x4040404040404fb,0x8080808080808f7,0x10101010101010ef,0x20202020202020df,0x40404040404040bf,0x808080808080807f,0x10101010101fe01,0x20202020202fd02,0x40404040404fb04,0x80808080808f708,0x101010101010ef10,0x202020202020df20,0x404040404040bf40,0x8080808080807f80,0x101010101fe0101,0x202020202fd0202,0x404040404fb0404,0x808080808f70808,0x1010101010ef1010,0x2020202020df2020,0x4040404040bf4040,0x80808080807f8080,0x1010101fe010101,0x2020202fd020202,0x4040404fb040404,0x8080808f7080808,0x10101010ef101010,0x20202020df202020,0x40404040bf404040,0x808080807f808080,0x10101fe01010101,0x20202fd02020202,0x40404fb04040404,0x80808f708080808,0x101010ef10101010,0x202020df20202020,0x404040bf40404040,0x8080807f80808080,0x101fe0101010101,0x202fd0202020202,0x404fb0404040404,0x808f70808080808,0x1010ef1010101010,0x2020df2020202020,0x4040bf4040404040,0x80807f8080808080,0x1fe010101010101,0x2fd020202020202,0x4fb040404040404,0x8f7080808080808,0x10ef101010101010,0x20df202020202020,0x40bf404040404040,0x807f808080808080,0xfe01010101010101,0xfd02020202020202,0xfb04040404040404,0xf708080808080808,0xef10101010101010,0xdf20202020202020,0xbf40404040404040,0x7f80808080808080,
0x81412111090503fe,0x2824222120a07fd,0x404844424150efb,0x8080888492a1cf7,0x10101011925438ef,0x2020212224a870df,0x404142444850e0bf,0x8182848890a0c07f,0x412111090503fe03,0x824222120a07fd07,0x4844424150efb0e,0x80888492a1cf71c,0x101011925438ef38,0x20212224a870df70,0x4142444850e0bfe0,0x82848890a0c07fc0,0x2111090503fe0305,0x4222120a07fd070a,0x844424150efb0e15,0x888492a1cf71c2a,0x1011925438ef3854,0x212224a870df70a8,0x42444850e0bfe050,0x848890a0c07fc0a0,0x11090503fe030509,0x22120a07fd070a12,0x4424150efb0e1524,0x88492a1cf71c2a49,0x11925438ef385492,0x2224a870df70a824,0x444850e0bfe05048,0x8890a0c07fc0a090,0x90503fe03050911,0x120a07fd070a1222,0x24150efb0e152444,0x492a1cf71c2a4988,0x925438ef38549211,0x24a870df70a82422,0x4850e0bfe0504844,0x90a0c07fc0a09088,0x503fe0305091121,0xa07fd070a122242,0x150efb0e15244484,0x2a1cf71c2a498808,0x5438ef3854921110,0xa870df70a8242221,0x50e0bfe050484442,0xa0c07fc0a0908884,0x3fe030509112141,0x7fd070a12224282,0xefb0e1524448404,0x1cf71c2a49880808,0x38ef385492111010,0x70df70a824222120,0xe0bfe05048444241,0xc07fc0a090888482,0xfe03050911214181,0xfd070a1222428202,0xfb0e152444840404,0xf71c2a4988080808,0xef38549211101010,0xdf70a82422212020,0xbfe0504844424140,0x7fc0a09088848281,
0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x200,0x500,0xa00,0x1400,0x2800,0x5000,0xa000,0x4000,0x20000,0x50000,0xa0000,0x140000,0x280000,0x500000,0xa00000,0x400000,0x2000000,0x5000000,0xa000000,0x14000000,0x28000000,0x50000000,0xa0000000,0x40000000,0x200000000,0x500000000,0xa00000000,0x1400000000,0x2800000000,0x5000000000,0xa000000000,0x4000000000,0x20000000000,0x50000000000,0xa0000000000,0x140000000000,0x280000000000,0x500000000000,0xa00000000000,0x400000000000,0x2000000000000,0x5000000000000,0xa000000000000,0x14000000000000,0x28000000000000,0x50000000000000,0xa0000000000000,0x40000000000000,0x200000000000000,0x500000000000000,0xa00000000000000,0x1400000000000000,0x2800000000000000,0x5000000000000000,0xa000000000000000,0x4000000000000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x20400,0x50800,0xa1100,0x142200,0x284400,0x508800,0xa01000,0x402000,0x2040004,0x5080008,0xa110011,0x14220022,0x28440044,0x50880088,0xa0100010,0x40200020,0x204000402,0x508000805,0xa1100110a,0x1422002214,0x2844004428,0x5088008850,0xa0100010a0,0x4020002040,0x20400040200,0x50800080500,0xa1100110a00,0x142200221400,0x284400442800,0x508800885000,0xa0100010a000,0x402000204000,0x2040004020000,0x5080008050000,0xa1100110a0000,0x14220022140000,0x28440044280000,0x50880088500000,0xa0100010a00000,0x40200020400000,0x204000402000000,0x508000805000000,0xa1100110a000000,0x1422002214000000,0x2844004428000000,0x5088008850000000,0xa0100010a0000000,0x4020002040000000,0x400040200000000,0x800080500000000,0x1100110a00000000,0x2200221400000000,0x4400442800000000,0x8800885000000000,0x100010a000000000,0x2000204000000000,0x4020000000000,0x8050000000000,0x110a0000000000,0x22140000000000,0x44280000000000,0x88500000000000,0x10a00000000000,0x20400000000000,
0x302,0x705,0xe0a,0x1c14,0x3828,0x7050,0xe0a0,0xc040,0x30203,0x70507,0xe0a0e,0x1c141c,0x382838,0x705070,0xe0a0e0,0xc040c0,0x3020300,0x7050700,0xe0a0e00,0x1c141c00,0x38283800,0x70507000,0xe0a0e000,0xc040c000,0x302030000,0x705070000,0xe0a0e0000,0x1c141c0000,0x3828380000,0x7050700000,0xe0a0e00000,0xc040c00000,0x30203000000,0x70507000000,0xe0a0e000000,0x1c141c000000,0x382838000000,0x705070000000,0xe0a0e0000000,0xc040c0000000,0x3020300000000,0x7050700000000,0xe0a0e00000000,0x1c141c00000000,0x38283800000000,0x70507000000000,0xe0a0e000000000,0xc040c000000000,0x302030000000000,0x705070000000000,0xe0a0e0000000000,0x1c141c0000000000,0x3828380000000000,0x7050700000000000,0xe0a0e00000000000,0xc040c00000000000,0x203000000000000,0x507000000000000,0xa0e000000000000,0x141c000000000000,0x2838000000000000,0x5070000000000000,0xa0e0000000000000,0x40c0000000000000,
0x8040201008040200,0x80402010080500,0x804020110a00,0x8041221400,0x182442800,0x10204885000,0x102040810a000,0x102040810204000,0x4020100804020002,0x8040201008050005,0x804020110a000a,0x804122140014,0x18244280028,0x1020488500050,0x102040810a000a0,0x204081020400040,0x2010080402000204,0x4020100805000508,0x804020110a000a11,0x80412214001422,0x1824428002844,0x102048850005088,0x2040810a000a010,0x408102040004020,0x1008040200020408,0x2010080500050810,0x4020110a000a1120,0x8041221400142241,0x182442800284482,0x204885000508804,0x40810a000a01008,0x810204000402010,0x804020002040810,0x1008050005081020,0x20110a000a112040,0x4122140014224180,0x8244280028448201,0x488500050880402,0x810a000a0100804,0x1020400040201008,0x402000204081020,0x805000508102040,0x110a000a11204080,0x2214001422418000,0x4428002844820100,0x8850005088040201,0x10a000a010080402,0x2040004020100804,0x200020408102040,0x500050810204080,0xa000a1120408000,0x1400142241800000,0x2800284482010000,0x5000508804020100,0xa000a01008040201,0x4000402010080402,0x2040810204080,0x5081020408000,0xa112040800000,0x14224180000000,0x28448201000000,0x50880402010000,0xa0100804020100,0x40201008040201,
0x1010101010101fe,0x2020202020202fd,0x4040404040404fb,0x8080808080808f7,0x10101010101010ef,0x20202020202020df,0x40404040404040bf,0x808080808080807f,0x10101010101fe01,0x20202020202fd02,0x40404040404fb04,0x80808080808f708,0x101010101010ef10,0x202020202020df20,0x404040404040bf40,0x8080808080807f80,0x101010101fe0101,0x202020202fd0202,0x404040404fb0404,0x808080808f70808,0x1010101010ef1010,0x2020202020df2020,0x4040404040bf4040,0x80808080807f8080,0x1010101fe010101,0x2020202fd020202,0x4040404fb040404,0x8080808f7080808,0x10101010ef101010,0x20202020df202020,0x40404040bf404040,0x808080807f808080,0x10101fe01010101,0x20202fd02020202,0x40404fb04040404,0x80808f708080808,0x101010ef10101010,0x202020df20202020,0x404040bf40404040,0x8080807f80808080,0x101fe0101010101,0x202fd0202020202,0x404fb0404040404,0x808f70808080808,0x1010ef1010101010,0x2020df2020202020,0x4040bf4040404040,0x80807f8080808080,0x1fe010101010101,0x2fd020202020202,0x4fb040404040404,0x8f7080808080808,0x10ef101010101010,0x20df202020202020,0x40bf404040404040,0x807f808080808080,0xfe01010101010101,0xfd02020202020202,0xfb04040404040404,0xf708080808080808,0xef10101010101010,0xdf20202020202020,0xbf40404040404040,0x7f80808080808080,
0x81412111090503fe,0x2824222120a07fd,0x404844424150efb,0x8080888492a1cf7,0x10101011925438ef,0x2020212224a870df,0x404142444850e0bf,0x8182848890a0c07f,0x412111090503fe03,0x824222120a07fd07,0x4844424150efb0e,0x80888492a1cf71c,0x101011925438ef38,0x20212224a870df70,0x4142444850e0bfe0,0x82848890a0c07fc0,0x2111090503fe0305,0x4222120a07fd070a,0x844424150efb0e15,0x888492a1cf71c2a,0x1011925438ef3854,0x212224a870df70a8,0x42444850e0bfe050,0x848890a0c07fc0a0,0x11090503fe030509,0x22120a07fd070a12,0x4424150efb0e1524,0x88492a1cf71c2a49,0x11925438ef385492,0x2224a870df70a824,0x444850e0bfe05048,0x8890a0c07fc0a090,0x90503fe03050911,0x120a07fd070a1222,0x24150efb0e152444,0x492a1cf71c2a4988,0x925438ef38549211,0x24a870df70a82422,0x4850e0bfe0504844,0x90a0c07fc0a09088,0x503fe0305091121,0xa07fd070a122242,0x150efb0e15244484,0x2a1cf71c2a498808,0x5438ef3854921110,0xa870df70a8242221,0x50e0bfe050484442,0xa0c07fc0a0908884,0x3fe030509112141,0x7fd070a12224282,0xefb0e1524448404,0x1cf71c2a49880808,0x38ef385492111010,0x70df70a824222120,0xe0bfe05048444241,0xc07fc0a090888482,0xfe03050911214181,0xfd070a1222428202,0xfb0e152444840404,0xf71c2a4988080808,0xef38549211101010,0xdf70a82422212020,0xbfe0504844424140,0x7fc0a09088848281
};

__constant Bitboard PawnAttackTables[4*64] = 
{
0x200,0x500,0xa00,0x1400,0x2800,0x5000,0xa000,0x4000,0x20000,0x50000,0xa0000,0x140000,0x280000,0x500000,0xa00000,0x400000,0x2000000,0x5000000,0xa000000,0x14000000,0x28000000,0x50000000,0xa0000000,0x40000000,0x200000000,0x500000000,0xa00000000,0x1400000000,0x2800000000,0x5000000000,0xa000000000,0x4000000000,0x20000000000,0x50000000000,0xa0000000000,0x140000000000,0x280000000000,0x500000000000,0xa00000000000,0x400000000000,0x2000000000000,0x5000000000000,0xa000000000000,0x14000000000000,0x28000000000000,0x50000000000000,0xa0000000000000,0x40000000000000,0x200000000000000,0x500000000000000,0xa00000000000000,0x1400000000000000,0x2800000000000000,0x5000000000000000,0xa000000000000000,0x4000000000000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x5,0xa,0x14,0x28,0x50,0xa0,0x40,0x200,0x500,0xa00,0x1400,0x2800,0x5000,0xa000,0x4000,0x20000,0x50000,0xa0000,0x140000,0x280000,0x500000,0xa00000,0x400000,0x2000000,0x5000000,0xa000000,0x14000000,0x28000000,0x50000000,0xa0000000,0x40000000,0x200000000,0x500000000,0xa00000000,0x1400000000,0x2800000000,0x5000000000,0xa000000000,0x4000000000,0x20000000000,0x50000000000,0xa0000000000,0x140000000000,0x280000000000,0x500000000000,0xa00000000000,0x400000000000,0x2000000000000,0x5000000000000,0xa000000000000,0x14000000000000,0x28000000000000,0x50000000000000,0xa0000000000000,0x40000000000000,
0x100,0x200,0x400,0x800,0x1000,0x2000,0x4000,0x8000,0x10000,0x20000,0x40000,0x80000,0x100000,0x200000,0x400000,0x800000,0x1000000,0x2000000,0x4000000,0x8000000,0x10000000,0x20000000,0x40000000,0x80000000,0x100000000,0x200000000,0x400000000,0x800000000,0x1000000000,0x2000000000,0x4000000000,0x8000000000,0x10000000000,0x20000000000,0x40000000000,0x80000000000,0x100000000000,0x200000000000,0x400000000000,0x800000000000,0x1000000000000,0x2000000000000,0x4000000000000,0x8000000000000,0x10000000000000,0x20000000000000,0x40000000000000,0x80000000000000,0x100000000000000,0x200000000000000,0x400000000000000,0x800000000000000,0x1000000000000000,0x2000000000000000,0x4000000000000000,0x8000000000000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x2,0x4,0x8,0x10,0x20,0x40,0x80,0x100,0x200,0x400,0x800,0x1000,0x2000,0x4000,0x8000,0x10000,0x20000,0x40000,0x80000,0x100000,0x200000,0x400000,0x800000,0x1000000,0x2000000,0x4000000,0x8000000,0x10000000,0x20000000,0x40000000,0x80000000,0x100000000,0x200000000,0x400000000,0x800000000,0x1000000000,0x2000000000,0x4000000000,0x8000000000,0x10000000000,0x20000000000,0x40000000000,0x80000000000,0x100000000000,0x200000000000,0x400000000000,0x800000000000,0x1000000000000,0x2000000000000,0x4000000000000,0x8000000000000,0x10000000000000,0x20000000000000,0x40000000000000,0x80000000000000
};


// index by rank
__constant Bitboard RankBB[8] =
{
0xff ,0xff00 ,0xff0000 ,0xff000000 ,0xff00000000 ,0xff0000000000 ,0xff000000000000 ,0xff00000000000000
};
// index by file
__constant Bitboard AdjacentFilesBB[8] =
{
0x202020202020202 ,0x505050505050505 ,0xa0a0a0a0a0a0a0a ,0x1414141414141414 ,0x2828282828282828 ,0x5050505050505050 ,0xa0a0a0a0a0a0a0a0 ,0x4040404040404040
};
// indexed by som*64 + square
__constant Bitboard ForwardBB[2*64] = 
{
0x101010101010100 ,0x202020202020200 ,0x404040404040400 ,0x808080808080800 ,0x1010101010101000 ,0x2020202020202000 ,0x4040404040404000 ,0x8080808080808000 ,0x101010101010000 ,0x202020202020000 ,0x404040404040000 ,0x808080808080000 ,0x1010101010100000 ,0x2020202020200000 ,0x4040404040400000 ,0x8080808080800000 ,0x101010101000000 ,0x202020202000000 ,0x404040404000000 ,0x808080808000000 ,0x1010101010000000 ,0x2020202020000000 ,0x4040404040000000 ,0x8080808080000000 ,0x101010100000000 ,0x202020200000000 ,0x404040400000000 ,0x808080800000000 ,0x1010101000000000 ,0x2020202000000000 ,0x4040404000000000 ,0x8080808000000000 ,0x101010000000000 ,0x202020000000000 ,0x404040000000000 ,0x808080000000000 ,0x1010100000000000 ,0x2020200000000000 ,0x4040400000000000 ,0x8080800000000000 ,0x101000000000000 ,0x202000000000000 ,0x404000000000000 ,0x808000000000000 ,0x1010000000000000 ,0x2020000000000000 ,0x4040000000000000 ,0x8080000000000000 ,0x100000000000000 ,0x200000000000000 ,0x400000000000000 ,0x800000000000000 ,0x1000000000000000 ,0x2000000000000000 ,0x4000000000000000 ,0x8000000000000000 ,0x0000000000000000 ,0x0000000000000000 ,0x0000000000000000 ,0x0000000000000000 ,0x0000000000000000 ,0x0000000000000000 ,0x0000000000000000 ,0x0000000000000000 ,
0x0000000000000000 ,0x0000000000000000 ,0x0000000000000000 ,0x0000000000000000 ,0x0000000000000000 ,0x0000000000000000 ,0x0000000000000000 ,0x0000000000000000 ,0x1 ,0x2 ,0x4 ,0x8 ,0x10 ,0x20 ,0x40 ,0x80 ,0x101 ,0x202 ,0x404 ,0x808 ,0x1010 ,0x2020 ,0x4040 ,0x8080 ,0x10101 ,0x20202 ,0x40404 ,0x80808 ,0x101010 ,0x202020 ,0x404040 ,0x808080 ,0x1010101 ,0x2020202 ,0x4040404 ,0x8080808 ,0x10101010 ,0x20202020 ,0x40404040 ,0x80808080 ,0x101010101 ,0x202020202 ,0x404040404 ,0x808080808 ,0x1010101010 ,0x2020202020 ,0x4040404040 ,0x8080808080 ,0x10101010101 ,0x20202020202 ,0x40404040404 ,0x80808080808 ,0x101010101010 ,0x202020202020 ,0x404040404040 ,0x808080808080 ,0x1010101010101 ,0x2020202020202 ,0x4040404040404 ,0x8080808080808 ,0x10101010101010 ,0x20202020202020 ,0x40404040404040 ,0x80808080808080
};

// indexed by som*64 + square
__constant Bitboard InFrontBB[2*64] = 
{
0xffffffffffffff00 ,0xffffffffffffff00 ,0xffffffffffffff00 ,0xffffffffffffff00 ,0xffffffffffffff00 ,0xffffffffffffff00 ,0xffffffffffffff00 ,0xffffffffffffff00 ,0xffffffffffff0000 ,0xffffffffffff0000 ,0xffffffffffff0000 ,0xffffffffffff0000 ,0xffffffffffff0000 ,0xffffffffffff0000 ,0xffffffffffff0000 ,0xffffffffffff0000 ,0xffffffffff000000 ,0xffffffffff000000 ,0xffffffffff000000 ,0xffffffffff000000 ,0xffffffffff000000 ,0xffffffffff000000 ,0xffffffffff000000 ,0xffffffffff000000 ,0xffffffff00000000 ,0xffffffff00000000 ,0xffffffff00000000 ,0xffffffff00000000 ,0xffffffff00000000 ,0xffffffff00000000 ,0xffffffff00000000 ,0xffffffff00000000 ,0xffffff0000000000 ,0xffffff0000000000 ,0xffffff0000000000 ,0xffffff0000000000 ,0xffffff0000000000 ,0xffffff0000000000 ,0xffffff0000000000 ,0xffffff0000000000 ,0xffff000000000000 ,0xffff000000000000 ,0xffff000000000000 ,0xffff000000000000 ,0xffff000000000000 ,0xffff000000000000 ,0xffff000000000000 ,0xffff000000000000 ,0xff00000000000000 ,0xff00000000000000 ,0xff00000000000000 ,0xff00000000000000 ,0xff00000000000000 ,0xff00000000000000 ,0xff00000000000000 ,0xff00000000000000 ,0x0000000000000000 ,0x0000000000000000 ,0x0000000000000000 ,0x0000000000000000 ,0x0000000000000000 ,0x0000000000000000 ,0x0000000000000000 ,0x0000000000000000 ,
0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xffff ,0xffff ,0xffff ,0xffff ,0xffff ,0xffff ,0xffff ,0xffff ,0xffffff ,0xffffff ,0xffffff ,0xffffff ,0xffffff ,0xffffff ,0xffffff ,0xffffff ,0xffffffff ,0xffffffff ,0xffffffff ,0xffffffff ,0xffffffff ,0xffffffff ,0xffffffff ,0xffffffff ,0xffffffffff ,0xffffffffff ,0xffffffffff ,0xffffffffff ,0xffffffffff ,0xffffffffff ,0xffffffffff ,0xffffffffff ,0xffffffffffff ,0xffffffffffff ,0xffffffffffff ,0xffffffffffff ,0xffffffffffff ,0xffffffffffff ,0xffffffffffff ,0xffffffffffff ,0xffffffffffffff ,0xffffffffffffff ,0xffffffffffffff ,0xffffffffffffff ,0xffffffffffffff ,0xffffffffffffff ,0xffffffffffffff ,0xffffffffffffff 
};


// Eval ported from Stockfish

__constant Score  MidgameLimit = 15581;
__constant Score  EndgameLimit = 3998;


// WeightsInternal, indexed by Mobility, PassedPawns, Space, KingDangerUs, KingDangerThem
__constant Score EvalSfWeightsInternal[5] =
{
18940248 ,14483729 ,3014656 ,17760256 ,20119552
};

// Empty+PNKBRQ
__constant Score EvalSfWood[7] =
{
0,12976386 ,53543758 ,0 ,54788953 ,83231998 ,165218814
};

// Empty+PNKBRQ
__constant Score EvalSfPsqt[7*64] = 
{
0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,
0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,-1835016 ,-393224 ,262136 ,917496 ,917496 ,262136 ,-393224 ,-1835016 ,-1835016 ,-393224 ,589816 ,2359288 ,2359288 ,589816 ,-393224 ,-1835016 ,-1835016 ,-393224 ,1114104 ,3801080 ,3801080 ,1114104 ,-393224 ,-1835016 ,-1835016 ,-393224 ,1114104 ,2359288 ,2359288 ,1114104 ,-393224 ,-1835016 ,-1835016 ,-393224 ,589816 ,917496 ,917496 ,589816 ,-393224 ,-1835016 ,-1835016 ,-393224 ,262136 ,917496 ,917496 ,262136 ,-393224 ,-1835016 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,
-8847464 ,-7012431 ,-5242935 ,-4390954 ,-4390954 ,-5242935 ,-7012431 ,-8847464 ,-6094927 ,-4390967 ,-2555934 ,-1638417 ,-1638417 ,-2555934 ,-4390967 ,-6094927 ,-3473463 ,-1638430 ,65530 ,851973 ,851973 ,65530 ,-1638430 ,-3473463 ,-1638442 ,65519 ,1769477 ,2686994 ,2686994 ,1769477 ,65519 ,-1638442 ,-720938 ,851951 ,2686981 ,3604498 ,3604498 ,2686981 ,851951 ,-720938 ,-720951 ,851938 ,2686970 ,3604485 ,3604485 ,2686970 ,851938 ,-720951 ,-3473487 ,-1638455 ,65506 ,851951 ,851951 ,65506 ,-1638455 ,-3473487 ,-12648552 ,-4390991 ,-2555959 ,-1638442 ,-1638442 ,-2555959 ,-4390991 ,-12648552 ,
18808850 ,20381773 ,17170537 ,14024839 ,14024839 ,17170537 ,20381773 ,18808850 ,17170509 ,18808967 ,15597733 ,12452033 ,12452033 ,15597733 ,18808967 ,17170509 ,14024809 ,15597733 ,12452033 ,9306334 ,9306334 ,12452033 ,15597733 ,14024809 ,12451975 ,14024897 ,10944734 ,7799035 ,7799035 ,10944734 ,14024897 ,12451975 ,10944647 ,12452033 ,9306334 ,6160635 ,6160635 ,9306334 ,12452033 ,10944647 ,9306217 ,10944677 ,7798977 ,4522206 ,4522206 ,7798977 ,10944677 ,9306217 ,7798861 ,9306247 ,6160549 ,3014849 ,3014849 ,6160549 ,9306247 ,7798861 ,6160402 ,7798861 ,4522089 ,1376391 ,1376391 ,4522089 ,7798861 ,6160402 ,
-2621499 ,-2621482 ,-2293795 ,-1966106 ,-1966106 ,-2293795 ,-2621482 ,-2621499 ,-1114154 ,-26 ,-262162 ,-11 ,-11 ,-262162 ,-26 ,-1114154 ,-852003 ,-262162 ,524277 ,262140 ,262140 ,524277 ,-262162 ,-852003 ,-524314 ,-11 ,262140 ,1114116 ,1114116 ,262140 ,-11 ,-524314 ,-524314 ,-11 ,262140 ,1114116 ,1114116 ,262140 ,-11 ,-524314 ,-852003 ,-262162 ,524277 ,262140 ,262140 ,524277 ,-262162 ,-852003 ,-1114154 ,-26 ,-262162 ,-11 ,-11 ,-262162 ,-26 ,-1114154 ,-1114171 ,-1114154 ,-852003 ,-524314 ,-524314 ,-852003 ,-1114154 ,-1114171 ,
-786429 ,-458749 ,-131069 ,131075 ,131075 ,-131069 ,-458749 ,-786429 ,-786429 ,-458749 ,-131069 ,131075 ,131075 ,-131069 ,-458749 ,-786429 ,-786429 ,-458749 ,-131069 ,131075 ,131075 ,-131069 ,-458749 ,-786429 ,-786429 ,-458749 ,-131069 ,131075 ,131075 ,-131069 ,-458749 ,-786429 ,-786429 ,-458749 ,-131069 ,131075 ,131075 ,-131069 ,-458749 ,-786429 ,-786429 ,-458749 ,-131069 ,131075 ,131075 ,-131069 ,-458749 ,-786429 ,-786429 ,-458749 ,-131069 ,131075 ,131075 ,-131069 ,-458749 ,-786429 ,-786429 ,-458749 ,-131069 ,131075 ,131075 ,-131069 ,-458749 ,-786429 ,
524208 ,524234 ,524246 ,524258 ,524258 ,524246 ,524234 ,524208 ,524234 ,524258 ,524270 ,524282 ,524282 ,524270 ,524258 ,524234 ,524246 ,524270 ,524282 ,524294 ,524294 ,524282 ,524270 ,524246 ,524258 ,524282 ,524294 ,524306 ,524306 ,524294 ,524282 ,524258 ,524258 ,524282 ,524294 ,524306 ,524306 ,524294 ,524282 ,524258 ,524246 ,524270 ,524282 ,524294 ,524294 ,524282 ,524270 ,524246 ,524234 ,524258 ,524270 ,524282 ,524282 ,524270 ,524258 ,524234 ,524208 ,524234 ,524246 ,524258 ,524258 ,524246 ,524234 ,524208
};

// Empty+PNKBRQ
__constant Score EvalSfMobility[7*32] =
{
0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,
0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,
-2490401 ,-1638423 ,-786445 ,-3 ,786439 ,1638417 ,2031638 ,2490395 ,2490395 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,
0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,
-1638430 ,-720912 ,196606 ,1114124 ,2031642 ,2949160 ,3735604 ,4259900 ,4653121 ,4849733 ,4980807 ,5111881 ,5177418 ,5242955 ,5308492 ,5308492 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,
-1310756 ,-917523 ,-524291 ,-131059 ,262173 ,655406 ,917566 ,1245263 ,1507423 ,1704042 ,1769583 ,1835122 ,1900660 ,1966197 ,2031734 ,2097270 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,
-655378 ,-524301 ,-393223 ,-196610 ,-65533 ,65544 ,196621 ,327699 ,524311 ,655387 ,786464 ,983074 ,1048611 ,1114147 ,1179683 ,1310755 ,1310755 ,1310755 ,1310755 ,1310755 ,1310755 ,1310755 ,1310755 ,1310755 ,1310755 ,1310755 ,1310755 ,1310755 ,1310755 ,1310755 ,1310755 ,1310755

};

__constant Score EvalSfPawnStructureWeight = 15270089;

// Indexed by opposed and File
__constant Score EvalSfDoubledPawnPenalty[2*8] =
{
852011 ,1310768 ,1507376 ,1507376 ,1507376 ,1507376 ,1310768 ,852011 ,
852011 ,1310768 ,1507376 ,1507376 ,1507376 ,1507376 ,1310768 ,852011
};

// IsolatedPawnPenalty, indexed by opposed and file
__constant Score EvalSfIsolatedPawnPenalty[2*8] =
{
2424877 ,3538996 ,3932212 ,3932212 ,3932212 ,3932212 ,3538996 ,2424877 ,1638430 ,2359331 ,2621475 ,2621475 ,2621475 ,2621475 ,2359331 ,1638430
};

// BackwardPawnPenalty, indexed by opposed and file
__constant Score EvalSfBackwardPawnPenalty[2*8] =
{
1966122 ,2818094 ,3211310 ,3211310 ,3211310 ,3211310 ,2818094 ,1966122 ,1310748 ,1900575 ,2162719 ,2162719 ,2162719 ,2162719 ,1900575 ,1310748
};

// Indexed by File
__constant Score EvalSfChainBonus[8] =
{
720895 ,851967 ,851967 ,917503 ,917503 ,851967 ,851967 ,720895 
};

// indexe by rank
__constant Score EvalSfCandidateBonus[8] =
{
0 ,393229 ,393229 ,917533 ,2228292 ,5439654 ,0 ,0
};

// Indexed by rank
__constant Score EvalSfPassedPawnBonus[8] =
{
0,0 ,0 ,2621490 ,7864420 ,15728810 ,26214660 ,39321970
};

// indexed by Empty + PNKBRQ
__constant Score EvalSfThreatenedByPawnPenalty[7] =
{
0 ,0 ,0 ,5636214 ,3670086 ,3670086 ,4980835
};

__constant Score UndefendedMinorPenalty = 1638410;

// ThreatBonus, indexed by Attacker Empty+PNKBRQ -  Attacked Empty+PNKBRQ
__constant Score EvalSfThreatBonus[7*7] =
{
0 ,0 ,0 ,0 ,0 ,0 ,0 ,
0 ,0 ,0 ,0 ,0 ,0 ,0 ,
0 ,458791 ,0 ,0 ,1572913 ,2687076 ,2687076 ,
0 ,0 ,0 ,0 ,0 ,0 ,0 ,
0 ,458791 ,1572913 ,0 ,0 ,2687076 ,2687076 ,
0 ,22 ,983089 ,0 ,983089 ,0 ,1572913 ,
0 ,983079 ,983079 ,0 ,983079 ,983079 ,0
};

__constant Score BishopPawnsPenalty = 524300; 

Score make_score(int mg, int eg) { return (signed int)((mg << 16) + eg); }

Score mg_value(Score s) { return (Score)(((s + 32768) & ~0xffff) / 0x10000); }

Score eg_value(Score s) { return (Score)((int)((unsigned)(s) & 0x7fffu) - (int)((unsigned)(s) & 0x8000u));}

Score apply_weight(Score v, Score w) {
  return make_score(((Score)(mg_value(v)) * mg_value(w)) / 0x100,
                    ((Score)(eg_value(v)) * eg_value(w)) / 0x100);
}

Score getScore(Score s, S32 phase){return (phase==ENDGAME)? eg_value(s) : mg_value(s);}



int count_1s(Bitboard b) {
  b -= ((b>>1) & 0x5555555555555555);
  b = ((b>>2) & 0x3333333333333333) + (b & 0x3333333333333333);
  b = ((b>>4) + b) & 0x0F0F0F0F0F0F0F0F;
  b *= 0x0101010101010101;
  return (int)(b >> 56);
}


void domove(__private Bitboard *board, Move move) {

    Square from = (Square)(move & 0x3F);
    Square to   = (Square)((move>>6) & 0x3F);
    Square cpt  = (Square)((move>>12) & 0x3F);

    Bitboard pto   = ((move>>22) & 0xF);

    // castle info
    U32 castlefrom   = (U32)((move>>40) & 0x7F); // is set to illegal square 64 when empty
    U32 castleto     = (U32)((move>>47) & 0x7F); // is set to illegal square 64 when empty
    Bitboard castlepciece = ((move>>54) & 0xF);  // is set to 0 when PEMPTY

    // unset from capture to and castle from
    board[0] &= ClearMaskBB[from] & ClearMaskBB[cpt] & ClearMaskBB[to] & ClearMaskBB[castlefrom];
    board[1] &= ClearMaskBB[from] & ClearMaskBB[cpt] & ClearMaskBB[to] & ClearMaskBB[castlefrom];
    board[2] &= ClearMaskBB[from] & ClearMaskBB[cpt] & ClearMaskBB[to] & ClearMaskBB[castlefrom];
    board[3] &= ClearMaskBB[from] & ClearMaskBB[cpt] & ClearMaskBB[to] & ClearMaskBB[castlefrom];

    // set to
    board[0] |= (pto&1)<<to;
    board[1] |= ((pto>>1)&1)<<to;
    board[2] |= ((pto>>2)&1)<<to;
    board[3] |= ((pto>>3)&1)<<to;

    // set to castle rook
    if (castleto < 64 && (castlepciece>>1) == ROOK) {
        board[0] |= (castlepciece&1)<<castleto;
        board[1] |= ((castlepciece>>1)&1)<<castleto;
        board[2] |= ((castlepciece>>2)&1)<<castleto;
        board[3] |= ((castlepciece>>3)&1)<<castleto;
    }

}

void undomove(__private Bitboard *board, Move move) {

    Square from = (Square)(move & 0x3F);
    Square to   = (Square)((move>>6) & 0x3F);
    Square cpt  = (Square)((move>>12) & 0x3F);

    Bitboard pfrom = ((move>>18) & 0xF);
    Bitboard pcpt  = ((move>>26) & 0xF);

    // castle info
    U32 castlefrom   = (U32)((move>>40) & 0x7F); // is set to illegal square 64 when empty
    U32 castleto     = (U32)((move>>47) & 0x7F); // is set to illegal square 64 when empty
    Bitboard castlepciece = ((move>>54) & 0xF);  // is set to 0 when PEMPTY

    // unset capture, to and castle to
    board[0] &= ClearMaskBB[cpt] & ClearMaskBB[to] & ClearMaskBB[castleto];
    board[1] &= ClearMaskBB[cpt] & ClearMaskBB[to] & ClearMaskBB[castleto];
    board[2] &= ClearMaskBB[cpt] & ClearMaskBB[to] & ClearMaskBB[castleto];
    board[3] &= ClearMaskBB[cpt] & ClearMaskBB[to] & ClearMaskBB[castleto];

    // restore cpt
    board[0] |= (pcpt&1)<<cpt;
    board[1] |= ((pcpt>>1)&1)<<cpt;
    board[2] |= ((pcpt>>2)&1)<<cpt;
    board[3] |= ((pcpt>>3)&1)<<cpt;

    // restore from
    board[0] |= (pfrom&1)<<from;
    board[1] |= ((pfrom>>1)&1)<<from;
    board[2] |= ((pfrom>>2)&1)<<from;
    board[3] |= ((pfrom>>3)&1)<<from;

    // restore from castle rook
    if (castlefrom < 64 && (castlepciece>>1) == ROOK) {
        board[0] |= (castlepciece&1)<<castlefrom;
        board[1] |= ((castlepciece>>1)&1)<<castlefrom;
        board[2] |= ((castlepciece>>2)&1)<<castlefrom;
        board[3] |= ((castlepciece>>3)&1)<<castlefrom;
    }
}


/* ############################# */
/* ###         Hash          ### */
/* ############################# */

Hash computeHash(__private Bitboard *board) {

    Piece piece;
    int side;
    Square pos;
    Bitboard bbBoth[2];
    Bitboard bbWork = 0;
    Hash hash = 0;

    bbBoth[0]   = ( board[0] ^ (board[1] | board[2] | board[3]));
    bbBoth[1]   =   board[0];

    // for each side
    for(side=0; side<2;side++) {
        bbWork = bbBoth[side];

        // each piece
        while (bbWork) {
            // pop 1st bit
            pos     = ((Square)(BitTable[((bbWork & -bbWork) * 0x218a392cd3d5dbf) >> 58]) );
            bbWork &= (bbWork-1); 

            piece = ( ((board[0]>>pos) &1) + 2*((board[1]>>pos) &1) + 4*((board[2]>>pos) &1) + 8*((board[3]>>pos) &1) )>>1;

            hash ^= Zobrist[side*7*64+piece*64+pos];

        }
    }

    return hash;    
}

void updateHash(__private Bitboard *board, Move move) {

/*
    Square from = (Square)(move & 0x3F);
    Square to   = (Square)((move>>6) & 0x3F);
    Square cpt  = (Square)((move>>12) & 0x3F);

    Bitboard pfrom = ((move>>18) & 0xF)>>1;
    Bitboard pto   = ((move>>22) & 0xF)>>1;
    Bitboard pcpt  = ((move>>26) & 0xF)>>1;

    Square castlefrom   = (Square)((move>>40) & 0x7F); // is set to illegal square 64 when empty
    Square castleto     = (Square)((move>>47) & 0x7F); // is set to illegal square 64 when empty
    Bitboard castlepciece = ((move>>54) & 0xF)>>1;  // is set to 0 when PEMPTY
*/
    // from
    board[4] ^= Zobrist[(((move>>18) & 0xF)&1)*7*64+(((move>>18) & 0xF)>>1)*64+(move & 0x3F)];

    // to
    board[4] ^= Zobrist[(((move>>22) & 0xF)&1)*7*64+(((move>>22) & 0xF)>>1)*64+((move>>6) & 0x3F)];

    // capture
    if ( (((move>>26) & 0xF)>>1) != PEMPTY)
        board[4] ^= Zobrist[(((move>>26) & 0xF)&1)*7*64+(((move>>26) & 0xF)>>1)*64+((move>>12) & 0x3F)];

    // castle from
    if (((move>>40) & 0x7F) < ILL && (((move>>54) & 0xF)>>1) == ROOK )
        board[4] ^= Zobrist[(((move>>54) & 0xF)&1)*7*64+(((move>>54) & 0xF)>>1)*64+((move>>40) & 0x3F)];

    // castle to
    if (((move>>47) & 0x7F) < ILL && (((move>>54) & 0xF)>>1) == ROOK )
        board[4] ^= Zobrist[(((move>>54) & 0xF)&1)*7*64+(((move>>54) & 0xF)>>1)*64+((move>>47) & 0x3F)];
}


Move updateCR(Move move, Cr cr) {

    Square from   =  (Square)(move&0x3F);
    Piece piece   =  (Piece)(((move>>18)&0xF)>>1);
    int som       =  (int)((move>>18)&0xF)&1;

    // update castle rights, TODO: make nice
    // clear white queenside
    cr&= ( (piece == ROOK && som == WHITE && from == 0) || ( piece == KING && som == WHITE && from == 4)) ? 0xE : 0xF;
    // clear white kingside
    cr&= ( (piece == ROOK && som == WHITE && from == 7) || ( piece == KING && som == WHITE && from == 4)) ? 0xD : 0xF;
    // clear black queenside
    cr&= ( (piece == ROOK && som == BLACK && from == 56) || ( piece == KING && som == BLACK && from == 60)) ? 0xB : 0xF;
    // clear black kingside
    cr&= ( (piece == ROOK && som == BLACK && from == 63) || ( piece == KING && som == BLACK && from == 60)) ? 0x7 : 0xF;


    move &= 0xFFFFFF0FFFFFFFFF; // clear old cr
    move |= ((Move)cr<<36)&0x000000F000000000; // set new cr

    return move;
}

int PieceInCheck(   __private Bitboard *board, 
                    Square sq, 
                    int som, 
                    __global U64 *RAttacks, 
                    __global U64 *BAttacks
                ) 


{

    Bitboard bbWork = 0;
    Bitboard bbMoves = 0;
    Bitboard bbOpposite  = (som == WHITE)? board[0] : (board[0] ^ (board[1] | board[2] | board[3]));
    Bitboard bbBlockers  = (board[1] | board[2] | board[3]);

    // Rooks and Queens
    bbWork = (bbOpposite & board[1] & ~board[2] & board[3] ) | (bbOpposite & ~board[1] & board[2] & board[3] );
    bbMoves = ( RAttacks[RAttackIndex[sq] + (((bbBlockers & RMask[sq]) * RMult[sq]) >> RShift[sq])] );
    if (bbMoves & bbWork) {
        return 1;
    }
    // Bishops and Queen
    bbWork = (bbOpposite & ~board[1] & ~board[2] & board[3] ) | (bbOpposite & ~board[1] & board[2] & board[3] );
    bbMoves = ( BAttacks[BAttackIndex[sq] + (((bbBlockers & BMask[sq]) * BMult[sq]) >> BShift[sq])] ) ;
    if (bbMoves & bbWork) {
        return 1;
    }
    // Knights
    bbWork = (bbOpposite & ~board[1] & board[2] & ~board[3] );
    bbMoves = AttackTablesTo[((SwitchSide(som))*7*64)+KNIGHT*64+sq] ;
    if (bbMoves & bbWork) {
        return 1;
    }
    // Pawns
    bbWork = (bbOpposite & board[1] & ~board[2]  & ~board[3] );
    bbMoves = AttackTablesTo[((SwitchSide(som))*7*64)+PAWN*64+sq];
    if (bbMoves & bbWork) {
        return 1;
    }
    // King
    bbWork = (bbOpposite & board[1] & board[2] & ~board[3] );
    bbMoves = AttackTablesTo[((SwitchSide(som))*7*64)+KING*64+sq] ;
    if (bbMoves & bbWork) {
        return 1;
    } 

    return 0;
}


Score EvalMove(Move move) {

    // castle moves
    if ( (((move>>54)&0xF)>>1) == ROOK)
        return INF; 

    // MVA
    if ( (((move>>26)&0xF)>>1) == PEMPTY) 
        return getScore(EvalSfWood[(((move>>22)&0xF)>>1)], MIDGAME);
    // MVV-LVA
    else
        return getScore(EvalSfWood[(((move>>26)&0xF)>>1)], MIDGAME) * 16 - getScore(EvalSfWood[(((move>>22)&0xF)>>1)],MIDGAME);
}


__kernel void bestfirst_gpu(  
                            __global Bitboard *init_board,
                            __global NodeBlock *board_stack_1,
                            __global NodeBlock *board_stack_2,
                            __global S32 *global_return,
                            __global U64 *COUNTERS,
                            __global int *board_stack_top,
                            __global int *total_nodes_visited,
                            __global int *global_pid_movecounter,
                            __global int *global_pid_todoindex,
                            __global int *global_pid_ab_score,
                            __global Move *global_pid_moves,
                            __global int *global_finished,
                            __global int *global_movecount,
                            __global int *global_plyreached,
                            __global Hash *global_HashHistory,
                               const int som_init,
                               const int ply_init,
                               const int search_depth,
                               const int max_nodes_to_expand,
                               const int max_nodes_per_slot,
                               const U64 max_nodes,
                               const int max_depth,
                            __global U64 *RAttacks,
                            __global U64 *BAttacks
)

{

    __private Bitboard board[5];
    __global NodeBlock *board_stack;
    __global NodeBlock *board_stack_tmp;
    Bitboard bbAttacks[2*6];

    const S32 pid = get_global_id(0) * get_global_size(1) * get_global_size(2) + get_global_id(1) * get_global_size(2) + get_global_id(2);
    const S32 totalThreads = get_global_size(0)*get_global_size(1)*get_global_size(2);

    S32 index = 0;
    S32 current = 0;
    S32 parent  = 0;
    S32 child   = 0;

    S32 depth = search_depth;
    S32 sd = 0;
    U32 som = som_init;
    U32 color = WHITE;
    S32 ply = ply_init;

    Cr CR  = 0;
        
    Move move = 0;
    Move tmpmove = 0;
    Move lastmove = 0;

    Score score = 0;
    Score zeta = 0;
    Score tmpscore = 0;

    S32 mode = INIT;

    S32 silent = 0;
    S32 kic = 0;
    S32 rootkic = 0;
    S32 qs = 0;
    S32 i = 0;
    S32 j = 0;
    S32 n = 0;
    S32 k = 0;

    Square kingpos = 0;
    Square pos;
    Square to;
    Square cpt;   
    Square ep;
    Piece piece;
    Piece pieceto;
    Piece piececpt;

    Bitboard bbTemp         = 0;
    Bitboard bbAttacksW     = 0;
    Bitboard bbAttacksB     = 0;
    Bitboard bbWhite        = 0;
    Bitboard bbBlack        = 0;
    Bitboard bbWork         = 0;
    Bitboard bbMe           = 0;
    Bitboard bbOpposite     = 0;
    Bitboard bbBlockers     = 0;
    Bitboard bbMoves        = 0;


    // init vars

    // assign root node to pid 0
    if (pid == 0 && *board_stack_top == 1) {

        // root node
        index = 0;
        // get init board
        board[0] = init_board[0];
        board[1] = init_board[1];
        board[2] = init_board[2];
        board[3] = init_board[3];
        board[4] = init_board[4]; // Hash

        som     = som_init;
        ply     = ply_init;
        sd      = 0;

        lastmove = board_stack_1[0].move;
        mode    = EXPAND;
    }


    for(i=0;i<max_depth;i++) {

        global_pid_movecounter[pid*max_depth+i]             = 0;
        global_pid_todoindex[pid*max_depth+i]               = 0;
    }


    // main loop, TODO: Host based termination via CL_MEM_ALLOC_HOST_PTR        
    while( (*board_stack_top < max_nodes_to_expand && *global_finished < max_nodes*8 && *total_nodes_visited < max_nodes && *global_movecount < max_nodes*12) || (TERMINATESOFT == 1 && (mode!=INIT && mode != SELECTION)) ) {

        // Iterations Counter
        COUNTERS[pid]++;

        // single reply and mate hack
        if ( board_stack_1[0].children == 1 || board_stack_1[0].children == 0 || ( abs(board_stack_1[0].score) != INF && abs(board_stack_1[0].score) > MATESCORE )) {
            *global_return = board_stack_1[board_stack_1[0].child].move;
            break;
        }

        if (mode == INIT) {

            index = 0;
            board_stack_1[0].visits++;

            // get init board
            board[0] = init_board[0];
            board[1] = init_board[1];
            board[2] = init_board[2];
            board[3] = init_board[3];
            board[4] = init_board[4]; // Hash

            depth   = search_depth;
            som     = som_init;
            ply     = ply_init;
            sd      = 0;

            lastmove = board_stack_1[0].move;


            mode = SELECTION;

            zeta = board_stack_1[0].score;

        }

        if ( mode == SELECTION) {


            board_stack = (index >= max_nodes_per_slot)? board_stack_2 : board_stack_1;
            n = board_stack[(index%max_nodes_per_slot)].children;


            // check movecount
            if (n <= 0 ) {
                mode = INIT;
            }

            score = -1000000000;
            current = 0;
            k = -1;


		    // selecta best move
            for (i=0; i < n; i++ ) {
        
                child = board_stack[(index%max_nodes_per_slot)].child + i;

                board_stack_tmp = (child >= max_nodes_per_slot)? board_stack_2 : board_stack_1;

                // if child node is locked or dead
                if (board_stack_tmp[(child%max_nodes_per_slot)].lock > -1 || board_stack_tmp[(child%max_nodes_per_slot)].children == 0)
                    continue;

                // skip check mate
                tmpscore = -board_stack_tmp[(child%max_nodes_per_slot)].score;
                if ( SKIPMATE == 1 && index > 0 && abs(tmpscore) != INF && abs(tmpscore) >= MATESCORE )
                    continue;

                tmpscore+= (S32) (((float)board_stack[(index%max_nodes_per_slot)].visits) / (SMOOTHUCT*(float)board_stack_tmp[(child%max_nodes_per_slot)].visits+1)  ) ;
                // Prune bad score
                if (ZETAPRUNING == 1 && index > 0 && abs(board_stack_tmp[(child%max_nodes_per_slot)].score) != INF && abs(zeta) != INF && abs(zeta) < MATESCORE && tmpscore < zeta )
                    continue;

                // RootSearch
                if (ROOTSEARCH == 1 && index == 0)
                    tmpscore = -board_stack_tmp[(child%max_nodes_per_slot)].visits;
                // magic select formula
                else {
                    tmpscore = -board_stack_tmp[(child%max_nodes_per_slot)].score;
                    tmpscore*= SCOREWEIGHT;
                    tmpscore+= (S32) (((float)board_stack[(index%max_nodes_per_slot)].visits) / (SMOOTHUCT*(float)board_stack_tmp[(child%max_nodes_per_slot)].visits+1)  ) ;
                }

                if ( tmpscore > score ) {
                    score = tmpscore;
                    current = child;
                }
            }

            board_stack_tmp = (current >= max_nodes_per_slot)? board_stack_2 : board_stack_1;


            if (current > 0 && (board_stack_tmp[(current%max_nodes_per_slot)].lock > -1 || board_stack_tmp[(current%max_nodes_per_slot)].children == 0) )
                current = 0;

            // get lock
            if (current > 0 && board_stack_tmp[(current%max_nodes_per_slot)].children == -1) {
                atom_cmpxchg(&board_stack_tmp[(current%max_nodes_per_slot)].lock, -1, pid);
                k = atom_cmpxchg(&board_stack_tmp[(current%max_nodes_per_slot)].lock, pid, pid);
            }

            // if otherwise locked, repeat
            if (k != -1 && k != pid)
                current = 0;

            // got lock, do move and exit selection phase to expand phase
            if (k == pid ) {
                if (board_stack_tmp[(current%max_nodes_per_slot)].score == -INF)
                    mode = EVALLEAF;
                else
                    mode = EXPAND;
            }                    
            // nothing goes
            if ( current == 0 )
                mode = INIT;

            // got a child, do move
            if (current > 0) {

                board_stack_tmp[(current%max_nodes_per_slot)].visits++;

                move = board_stack_tmp[(current%max_nodes_per_slot)].move;

                lastmove = move;

                ply++;

                atom_max(global_plyreached, (ply-ply_init));

                domove(board, move);

                updateHash(board, move);

                global_HashHistory[pid*1024+ply] = board[4];

                som = SwitchSide(som);    

                index = current;

                zeta = board_stack_tmp[(current%max_nodes_per_slot)].score;
//                zeta = -zeta;
            }
        }

        if ( mode == INIT || mode == SELECTION ) {
            atom_inc(global_finished);
            continue;
        }

        atom_add(global_finished, 8);

        // #########################################
        // ####         Move Generator          ####
        // #########################################
        n = 0;
        k = 0;
        silent = 1;
        bbTemp      = board[1] | board[2] | board[3];
        bbMe        = (som == BLACK)? board[0]   : ( board[0] ^ bbTemp ) ;
        bbOpposite  = (som == BLACK)? ( board[0] ^ bbTemp ) : board[0];
        bbBlockers  = bbMe | bbOpposite;
        bbWork      = bbMe;

        //get king position
        bbTemp  = bbMe & board[1] & board[2] & ~board[3]; // get king
        kingpos = (Square)(BitTable[((bbTemp & -bbTemp) * 0x218a392cd3d5dbf) >> 58]); // get king square

        rootkic = 0;
        // king in check?
        rootkic = PieceInCheck(board, kingpos, som, RAttacks, BAttacks);

        CR = (Cr)((lastmove>>36)&0xF);

        // Quiescence Search?
        qs = (mode==EXPAND||mode==EVALLEAF||sd<=depth)?0:1;

        while( bbWork )  {

            bbTemp = 0;
            bbMoves = 0;

            // pop 1st bit
            pos     = ((Square)(BitTable[((bbWork & -bbWork) * 0x218a392cd3d5dbf) >> 58]) );
            bbWork &= (bbWork-1); 

            piece   = ((board[0]>>pos) &1) + 2*((board[1]>>pos) &1) + 4*((board[2]>>pos) &1) + 8*((board[3]>>pos) &1);

            // Knight and King
            bbTemp  |= ( (piece>>1) == KNIGHT || (piece>>1) == KING)? AttackTables[(som*7*64)+((piece>>1)*64)+pos] : 0;

            // Sliders
            // rook or queen
            bbTemp  |= ( (piece>>1) == ROOK || (piece>>1) == QUEEN)?      ( RAttacks[RAttackIndex[pos] + (((bbBlockers & RMask[pos]) * RMult[pos]) >> RShift[pos])] ) : 0;
            // bishop or queen
            bbTemp  |= ( (piece>>1) == BISHOP || (piece>>1) == QUEEN)?    ( BAttacks[BAttackIndex[pos] + (((bbBlockers & BMask[pos]) * BMult[pos]) >> BShift[pos])] ) : 0;

            // Pawn attacks and forward step
            bbTemp  |= ( (piece>>1) == PAWN) ? (PawnAttackTables[som*64+pos] & bbOpposite)  | (PawnAttackTables[(som+2)*64+pos] & ~bbBlockers)                        : 0 ;

            // Pawn double square
            if ( (piece>>1) == PAWN && ( ( som == WHITE && (pos>>3) == 1) || (som == BLACK && (pos>>3) == 6 ) ) ) {
                to  = (som == BLACK)? pos-8  : pos+8;
                cpt = (som == BLACK)? pos-16 : pos+16;
                if (   (~bbBlockers & SetMaskBB[to]) && (~bbBlockers & SetMaskBB[cpt]) )
                    bbTemp |= SetMaskBB[cpt];
            }

            // Captures
            bbMoves  = (bbTemp & bbOpposite);
            // Non cpatures
            bbMoves |= (qs == 0 || rootkic == 1)? bbTemp & ~bbBlockers : 0;

            while( bbMoves )  {

                // pop 1st bit
                to = ((Square)(BitTable[((bbMoves & -bbMoves) * 0x218a392cd3d5dbf) >> 58]) );
                bbMoves &= (bbMoves-1);

                // en passant to
                child = pos-to;
                ep = ( (piece>>1) == PAWN && abs(child) == 16 ) ? to : 0;

                cpt = to;
                pieceto = ( (piece>>1) == PAWN && ( (som == WHITE && (to>>3) == 7) || (som == BLACK && (to>>3) == 0) ) ) ? (QUEEN<<1 | som): piece; // pawn promotion

                piececpt = ((board[0]>>cpt) &1) + 2*((board[1]>>cpt) &1) + 4*((board[2]>>cpt) &1) + 8*((board[3]>>cpt) &1);

                // make move
                move = ( (((Move)pos)&0x000000000000003F) | (((Move)to<<6)&0x0000000000000FC0) | (((Move)cpt<<12)&0x000000000003F000) | (((Move)piece<<18)&0x00000000003C0000) | (((Move)pieceto<<22)&0x0000000003C00000) | (((Move)piececpt<<26)&0x000000003C000000) | (((Move)ep<<30)&0x0000000FC0000000) | (((Move)ILL<<40)&0x00007F0000000000) | (((Move)ILL<<47)&0x003F800000000000) | (((Move)PEMPTY<<54)&0x03C0000000000000) );

                // TODO: pseudo legal move gen: 2x speedup?
                // domove
                domove(board, move);

                //get king position
                bbTemp  = board[0] ^ (board[1] | board[2] | board[3]);
                bbTemp  = (som == BLACK)? board[0]   : bbTemp ;
                bbTemp  = bbTemp & board[1] & board[2] & ~board[3]; // get king
                kingpos = (Square)(BitTable[((bbTemp & -bbTemp) * 0x218a392cd3d5dbf) >> 58]);

                kic = 0;
                // king in check?
                kic = PieceInCheck(board, kingpos, som, RAttacks, BAttacks);

                if ( kic == 0 ) {

                    silent = ((piececpt>>1) != PEMPTY)? 0 : silent;

                    k++; // check mate move counter

                    if (qs == 0 || (qs == 1 && (piececpt>>1) != PEMPTY ) ) {
                        // update castle rights        
                        move = updateCR(move, CR);
                        // copy move to global
                        global_pid_moves[pid*max_depth*MAXLEGALMOVES+sd*MAXLEGALMOVES+n] = move;

                        // Movecounters
                        n++;
                        COUNTERS[totalThreads*3+pid]++;
                        atom_inc(global_movecount);

                        // sort move
                        child = pid*max_depth*MAXLEGALMOVES+sd*MAXLEGALMOVES+0;
                        for(j=n-1; j > 0; j--) {
                            if ( EvalMove(global_pid_moves[j+child]) > EvalMove(global_pid_moves[j-1+child])  ) {
                                tmpmove = global_pid_moves[j+child];
                                global_pid_moves[j+child] = global_pid_moves[j-1+child];
                                global_pid_moves[j-1+child] = tmpmove;
                           }
                           else
                            break;
                        }
                    }
                }

                // undomove
                undomove(board, move);

            }

        }



        // ################################
        // ####       Castle moves      ###
        // ################################
        // get Rooks
        bbOpposite  = (bbMe & board[1] & ~board[2] & board[3] );
        //get king position
        bbTemp  = bbMe & board[1] & board[2] & ~board[3]; // get king
        kingpos = (Square)(BitTable[((bbTemp & -bbTemp) * 0x218a392cd3d5dbf) >> 58]); // get king square

        // Queenside
        bbMoves  = (som == WHITE)? 0xE : 0x0E00000000000000;   
        bbMoves &= (board[1] | board[2] | board[3]); 

        if ( qs == 0 && ( (som == WHITE && (CR&0x1)) || (som == BLACK && (CR&0x4))) && ( (som == WHITE && kingpos == 4) || (som == BLACK && kingpos == 60) ) && rootkic == 0 && (!bbMoves) && (bbOpposite & SetMaskBB[kingpos-4]) ) {

            kic      = 0;            
            kic     += PieceInCheck(board, kingpos-2, som, RAttacks, BAttacks); // check C
            kic     += PieceInCheck(board, kingpos-1, som, RAttacks, BAttacks); // check D

            if (kic == 0) {

                // make move
                to = kingpos-4;
                cpt = kingpos-1;
                move = ( (((Move)kingpos)&0x000000000000003F) | (((Move)(kingpos-2)<<6)&0x0000000000000FC0) | (((Move)(kingpos-2)<<12)&0x000000000003F000) | (((Move)( (KING<<1) | (som&1))<<18)&0x00000000003C0000) | (((Move)( (KING<<1) | (som&1))<<22)&0x0000000003C00000) | (((Move)PEMPTY<<26)&0x000000003C000000) | (((Move)PEMPTY<<30)&0x0000000FC0000000) | (((Move)to<<40)&0x00007F0000000000) | (((Move)cpt<<47)&0x003F800000000000) | (((Move)( (ROOK<<1) | (som&1))<<54)&0x03C0000000000000) );

                // update castle rights        
                move = updateCR(move, CR);

                // copy move to global
                global_pid_moves[pid*max_depth*MAXLEGALMOVES+sd*MAXLEGALMOVES+n] = move;
                // Movecounters
                n++;
                k++;
                COUNTERS[totalThreads*3+pid]++;
                atom_inc(global_movecount);
            }
        }

        bbOpposite  = (bbMe & board[1] & ~board[2] & board[3] );
        //get king position
        bbTemp  = bbMe & board[1] & board[2] & ~board[3]; // get king
        kingpos = (Square)(BitTable[((bbTemp & -bbTemp) * 0x218a392cd3d5dbf) >> 58]); // get king square
     
        // kingside
        bbMoves  = (som == WHITE)? 0x60 : 0x6000000000000000;   
        bbMoves &= (board[1] | board[2] | board[3]); 

        if ( qs == 0 && ( (som == WHITE && (CR&0x2)) || (som == BLACK && (CR&0x8))) && ( (som == WHITE && kingpos == 4) || (som == BLACK && kingpos == 60) ) && rootkic == 0 && (!bbMoves)  && (bbOpposite & SetMaskBB[kingpos+3])) {


            kic      = 0;
            kic     += PieceInCheck(board, kingpos+1, som, RAttacks, BAttacks); // check F
            kic     += PieceInCheck(board, kingpos+2, som, RAttacks, BAttacks); // check G
        
            if (kic == 0) {

                // make move
                to = kingpos+3;
                cpt = kingpos+1;
                move = ( (((Move)kingpos)&0x000000000000003F) | (((Move)(kingpos+2)<<6)&0x0000000000000FC0) | (((Move)(kingpos+2)<<12)&0x000000000003F000) | (((Move)( (KING<<1) | (som&1))<<18)&0x00000000003C0000) | (((Move)( (KING<<1) | (som&1))<<22)&0x0000000003C00000) | (((Move)PEMPTY<<26)&0x000000003C000000) | (((Move)PEMPTY<<30)&0x0000000FC0000000) | (((Move)to<<40)&0x00007F0000000000) | (((Move)cpt<<47)&0x003F800000000000) | (((Move)( (ROOK<<1) | (som&1))<<54)&0x03C0000000000000) );

                // update castle rights        
                move = updateCR(move, CR);

                // copy move to global
                global_pid_moves[pid*max_depth*MAXLEGALMOVES+sd*MAXLEGALMOVES+n] = move;
                // Movecounters
                n++;
                k++;
                COUNTERS[totalThreads*3+pid]++;
                atom_inc(global_movecount);
            }
        }


        // ################################
        // ####     En passant moves    ###
        // ################################
        cpt = (lastmove>>30)&0x3F;

        if ( cpt ) {

            piece = ((PAWN<<1) | som);
            pieceto = piece;
            piececpt = ((PAWN<<1) | (SwitchSide(som)) );
            ep = 0;

            bbMoves  =  bbMe & board[1] & ~board[2]  & ~board[3];

            // white
            if ( som == WHITE ) {
                bbMoves &= (0xFF00000000 & (SetMaskBB[cpt+1] | SetMaskBB[cpt-1]) );
                
            }
            // black     
            else {
                bbMoves &= (0xFF000000 & (SetMaskBB[cpt+1] | SetMaskBB[cpt-1]) );
            }
            while(bbMoves){

                // pop 1st bit
                pos = ((Square)(BitTable[((bbMoves & -bbMoves) * 0x218a392cd3d5dbf) >> 58]) );
                bbMoves &= (bbMoves-1);

                to  = (som==BLACK)? cpt-8 : cpt+8;
                
                // make move
                move = ( (((Move)pos)&0x000000000000003F) | (((Move)to<<6)&0x0000000000000FC0) | (((Move)cpt<<12)&0x000000000003F000) | (((Move)piece<<18)&0x00000000003C0000) | (((Move)pieceto<<22)&0x0000000003C00000) | (((Move)piececpt<<26)&0x000000003C000000) | (((Move)ep<<30)&0x0000000FC0000000) | (((Move)ILL<<40)&0x00007F0000000000) | (((Move)ILL<<47)&0x003F800000000000) | (((Move)PEMPTY<<54)&0x03C0000000000000) );

                // domove
                domove(board, move);

                //get king position
                bbTemp  = board[0] ^ (board[1] | board[2] | board[3]);
                bbTemp  = (som == BLACK)? board[0]   : bbTemp ;
                bbTemp  = bbTemp & board[1] & board[2] & ~board[3]; // get king
                kingpos = (Square)(BitTable[((bbTemp & -bbTemp) * 0x218a392cd3d5dbf) >> 58]);

                kic = 0;
                // king in check?
                kic = PieceInCheck(board, kingpos, som, RAttacks, BAttacks);

                if (kic == 0) {

                    // update castle rights        
                    move = updateCR(move, CR);
                    // copy move to global
                    global_pid_moves[pid*max_depth*MAXLEGALMOVES+sd*MAXLEGALMOVES+n] = move;
                    // Movecounters
                    n++;
                    k++;
                    COUNTERS[totalThreads*3+pid]++;
                    atom_inc(global_movecount);
                }

                // undomove
                undomove(board, move);
            }
        }


        // ################################
        // ####        Evaluation       ###
        // ################################

        // new eval, mostly ported from Stockfish
        bbBlockers  = board[1] | board[2] | board[3];        // all pieces
        bbTemp      = board[1] & ~board[2] & ~board[3];      // all pawns
        bbWhite     = (board[0] ^ bbBlockers) & bbTemp;      // white pawns
        bbBlack     =  board[0] & bbTemp;                    // black pawns

        score = 0;
    
        // evaluate material and psqt
        // for each side
        for(color=WHITE; color<=BLACK;color++) {

            bbWork  = (color==WHITE)? (board[0]^bbBlockers) : board[0];

            // each piece
            while (bbWork) {

                // pop 1st bit
                pos     = ((Square)(BitTable[((bbWork & -bbWork) * 0x218a392cd3d5dbf) >> 58]) );
                bbWork &= (bbWork-1); 

                piece = ( ((board[0]>>pos) &1) + 2*((board[1]>>pos) &1) + 4*((board[2]>>pos) &1) + 8*((board[3]>>pos) &1) )>>1;

                // Wood Count
                score+= (color==BLACK)? -EvalSfWood[piece]                    : EvalSfWood[piece];
                // PieceSquareTables
                score+= (color==BLACK)? -EvalSfPsqt[piece*64+FLIPFLOP(pos)]   : EvalSfPsqt[piece*64+FLIP(pos)];
            }
        }

        // evaluate white pawns
        bbWork      = bbWhite;
        bbAttacks[0]= 0x0000000000000000;
        bbAttacks[1]= 0x0000000000000000;
        bbAttacks[2]= 0x0000000000000000;
        bbAttacks[3]= 0x0000000000000000;
        bbAttacks[4]= 0x0000000000000000;
        bbAttacks[5]= 0x0000000000000000;
        // each piece
        while (bbWork) {

            // pop 1st bit
            pos     = ((Square)(BitTable[((bbWork & -bbWork) * 0x218a392cd3d5dbf) >> 58]) );
            bbWork &= (bbWork-1); 

            // collect pawn attacks
            bbAttacks[0] |= PawnAttackTables[pos]; 

            CR  = 0x00000000; // store pawn flags
            tmpscore = 0;

            // opposed flag
            child= ( bbBlack & ForwardBB[pos])? 1: 0;
            // chain
            CR   = ( bbWhite & AdjacentFilesBB[(pos&7)] & (RankBB[(pos>>3)] | RankBB[(pos>>3)-1]) )? 0x1 : 0x0; 
            // isolated
            CR  |= ( bbWhite & AdjacentFilesBB[(pos&7)] )? 0x0 : 0x2;
            // double pawn
            CR  |= ( ForwardBB[pos] & bbWhite )? 0x4 : 0x0;
            // passed
            CR  |= ( InFrontBB[pos] & (ForwardBB[pos] | AdjacentFilesBB[(pos&7)]) & bbBlack )? 0x0 : 0x8;
            // backward pawn
            bbTemp = PawnAttackTables[pos];
            if ( !(CR&0x1) && !(CR&0x2) && !(CR&0x8) && !(bbTemp & bbBlack) && !(bbWhite & InFrontBB[BLACK*64+pos] & AdjacentFilesBB[(pos&7)]) ) {
                while( !(bbTemp & (bbWhite | bbBlack)) )
                    bbTemp = bbTemp<<8;
                // our pawn is at lest 2 ranks nearer than enemy pawn
                CR |= ( (bbTemp | (bbTemp<<8) ) & bbBlack)? 0x10 : 0; 
            }
            // passed candidate pawn
            if ( child == 0 && !(CR&0x2) && !(CR&0x8) && !(CR&0x10) ) {
                // behind and beside own pawns
                bbTemp = (bbWhite & InFrontBB[64+pos+8] & AdjacentFilesBB[(pos&7)]);
                kic = count_1s(bbTemp);
                // in front enemy pawns                
                bbTemp = (bbBlack & InFrontBB[pos] & AdjacentFilesBB[(pos&7)]);
                if (kic > 0 && kic > count_1s(bbTemp))
                    CR |= 0x20; 
            }

            // chain bonus
            if ( (CR&0x1) )
                tmpscore+= EvalSfChainBonus[(pos&7)];
            // isolated penalty
            if ( (CR&0x2) )
                tmpscore-= EvalSfIsolatedPawnPenalty[child*8+(pos&7)];
            // double penalty
            if ( (CR&0x4) )
                tmpscore-= EvalSfDoubledPawnPenalty[child*8+(pos&7)];
            // Passed Pawn Rank Bonus
            if ( (CR&0x8) && !(CR&0x4) )
                score+= apply_weight(EvalSfPassedPawnBonus[(pos>>3)], EvalSfWeightsInternal[1]);
            // backward penalty
            if ( (CR&0x10) )
                tmpscore-= EvalSfBackwardPawnPenalty[child*8+(pos&7)];
            // candidate bonus
            if ( (CR&0x20) )
                tmpscore+= EvalSfCandidateBonus[(pos>>3)];

            // apply weight and add score
            score+= apply_weight(tmpscore, EvalSfPawnStructureWeight);
        }

        // evaluate black pawns
        bbWork      = bbBlack;
        bbAttacks[6]= 0x0000000000000000;
        bbAttacks[7]= 0x0000000000000000;
        bbAttacks[8]= 0x0000000000000000;
        bbAttacks[9]= 0x0000000000000000;
        bbAttacks[10]= 0x0000000000000000;
        bbAttacks[11]= 0x0000000000000000;
        // each piece
        while (bbWork) {

            // pop 1st bit
            pos     = ((Square)(BitTable[((bbWork & -bbWork) * 0x218a392cd3d5dbf) >> 58]) );
            bbWork &= (bbWork-1); 

            // collect pawn attacks
            bbAttacks[6] |= PawnAttackTables[64+pos]; 

            CR  = 0x00000000; // store pawn flags
            tmpscore = 0;
            // opposed flag
            child= ( bbWhite & ForwardBB[64+pos])? 1: 0;
            // chain
            CR   = ( bbBlack & AdjacentFilesBB[(pos&7)] & (RankBB[(pos>>3)] | RankBB[(pos>>3)+1]) )? 0x1 : 0x0; 
            // isolated
            CR  |= ( bbBlack & AdjacentFilesBB[(pos&7)] )? 0x0 : 0x2;
            // double pawn
            CR  |= ( ForwardBB[64+pos] & bbBlack )? 0x4 : 0x0;
            // passed
            CR  |= ( InFrontBB[64+pos] & (ForwardBB[64+pos] | AdjacentFilesBB[(pos&7)]) & bbWhite )? 0x0 : 0x8;
            // backward pawn
            bbTemp = PawnAttackTables[64+pos];
            if ( !(CR&0x1) && !(CR&0x2) && !(CR&0x8) && !(bbTemp & bbWhite) && !(bbBlack & InFrontBB[pos] & AdjacentFilesBB[(pos&7)]) ) {
                while( !(bbTemp & (bbWhite | bbBlack)) )
                    bbTemp = bbTemp>>8;
                // our pawn is at lest 2 ranks nearer than enemy pawn
                CR |= ( (bbTemp | (bbTemp>>8) ) & bbWhite)? 0x10 : 0; 
            }
            // passed candidate pawn
            if ( child == 0 && !(CR&0x2) && !(CR&0x8) && !(CR&0x10) ) {
                // behind and beside own pawns
                bbTemp = (bbBlack & InFrontBB[(pos-8)] & AdjacentFilesBB[(pos&7)]);
                kic = count_1s(bbTemp);
                // in front enemy pawns                
                bbTemp = (bbWhite & InFrontBB[64+pos] & AdjacentFilesBB[(pos&7)]);
                if (kic > 0 && kic > count_1s(bbTemp))
                    CR |= 0x20; 
            }

            // chain bonus
            if ( (CR&0x1) )
                tmpscore-= EvalSfChainBonus[(pos&7)];
            // isolated penalty
            if ( (CR&0x2) )
                tmpscore+= EvalSfIsolatedPawnPenalty[child*8+(pos&7)];
            // double penalty
            if ( (CR&0x4) )
                tmpscore+= EvalSfDoubledPawnPenalty[child*8+(pos&7)];
            // Passed Pawn Rank Bonus
            if ( (CR&0x8) && !(CR&0x4) )
                score-= apply_weight(EvalSfPassedPawnBonus[RelativeRank(BLACK,(pos>>3))], EvalSfWeightsInternal[1]);
            // backward penalty
            if ( (CR&0x10) )
              tmpscore+= EvalSfBackwardPawnPenalty[child*8+(pos&7)];
            // candidate bonus
            if ( (CR&0x20) )
                tmpscore-= EvalSfCandidateBonus[RelativeRank(BLACK,(pos>>3))];

            // apply weight and add score
            score+= apply_weight(tmpscore, EvalSfPawnStructureWeight);
        }


        // evaluate mobility and collect attack tables
        bbWork  = bbBlockers; // all pieces
        bbWork ^=  ( board[1] & ~board[2] & ~board[3]); // except pawns

        // each piece
        while (bbWork) {

            // pop 1st bit
            pos     = ((Square)(BitTable[((bbWork & -bbWork) * 0x218a392cd3d5dbf) >> 58]) );
            bbWork &= (bbWork-1); 

            piece = ( ((board[0]>>pos) &1) + 2*((board[1]>>pos) &1) + 4*((board[2]>>pos) &1) + 8*((board[3]>>pos) &1) )>>1;

            // get color
            color = ((board[0]>>pos)&0x1);

            // mobility
            bbMoves  = ( piece==KNIGHT || piece==KING )? AttackTables[color*7*64+piece*64+pos] : 0;
            // rook or queen
            bbMoves |= ( piece == ROOK || piece == QUEEN )? ( RAttacks[RAttackIndex[pos] + (((bbBlockers & RMask[pos]) * RMult[pos]) >> RShift[pos])] ) : 0;
            // bishop or queen
            bbMoves |= ( piece == BISHOP || piece  == QUEEN )? ( BAttacks[BAttackIndex[pos] + (((bbBlockers & BMask[pos]) * BMult[pos]) >> BShift[pos])] ) : 0;

            // collect attacks
            bbAttacks[color*6+(piece-1)] |= bbMoves;

            // exclude enemy pawn attacks and own pieces for scoring
            bbTemp   = (color==WHITE)? ~( bbAttacks[6] | (board[0]^bbBlockers) ) : ~( bbAttacks[0] | board[0]);
            bbMoves &= bbTemp;

            kic = count_1s(bbMoves);
            kic = (kic >= 15 && piece != QUEEN)? 15 : kic;   // limit

            tmpscore = EvalSfMobility[piece*32+kic];

            // Threat by a Pawn?
            bbTemp = (color==WHITE)?  bbAttacks[6] :  bbAttacks[0];
            bbTemp&= SetMaskBB[pos];
            tmpscore-= (bbTemp)? EvalSfThreatenedByPawnPenalty[piece] : 0;

            // apply mobility weight and add score
            score+= (color==BLACK)? -apply_weight(tmpscore, EvalSfWeightsInternal[0]) : apply_weight(tmpscore, EvalSfWeightsInternal[0]);
        }


        // collect attacks
        bbAttacksW  = bbAttacks[0] | bbAttacks[1] | bbAttacks[2] | bbAttacks[3] | bbAttacks[4] | bbAttacks[5];
        bbAttacksB  = bbAttacks[6] | bbAttacks[7] | bbAttacks[8] | bbAttacks[9] | bbAttacks[10] | bbAttacks[11];

        // evaluate threats white
        tmpscore = 0;
        // enemy minor piece not defended?
        bbTemp = board[0] & ( (~board[1] & board[2] & ~board[3]) | (~board[1] & ~board[2] & board[3]) ); // knights n bishops
        bbTemp&= bbAttacksB;
        tmpscore+= (!bbTemp)? UndefendedMinorPenalty : 0;
        // Enemy pieces not defended by a pawn and under our attack
        bbTemp = board[0] & ~bbAttacks[6] & bbAttacksW;
        bbTemp^= ( board[1] & board[2] & ~board[3]); // except kings
        bbWork = bbTemp & bbAttacks[KNIGHT-1]; // enemy attacked by our knights
        // each enemy piece
        while (bbWork) {
            // pop 1st bit
            pos     = ((Square)(BitTable[((bbWork & -bbWork) * 0x218a392cd3d5dbf) >> 58]) );
            bbWork &= (bbWork-1); 
            piece = ( ((board[0]>>pos) &1) + 2*((board[1]>>pos) &1) + 4*((board[2]>>pos) &1) + 8*((board[3]>>pos) &1) )>>1;
            tmpscore+= EvalSfThreatBonus[KNIGHT*7+piece];
        }        
        bbWork = bbTemp & bbAttacks[BISHOP-1]; // enemy attacked by our bishops
        // each enemy piece
        while (bbWork) {
            // pop 1st bit
            pos     = ((Square)(BitTable[((bbWork & -bbWork) * 0x218a392cd3d5dbf) >> 58]) );
            bbWork &= (bbWork-1); 
            piece = ( ((board[0]>>pos) &1) + 2*((board[1]>>pos) &1) + 4*((board[2]>>pos) &1) + 8*((board[3]>>pos) &1) )>>1;
            tmpscore+= EvalSfThreatBonus[BISHOP*7+piece];
        }        
        bbWork = bbTemp & bbAttacks[ROOK-1]; // enemy attacked by our rooks
        // each enemy piece
        while (bbWork) {
            // pop 1st bit
            pos     = ((Square)(BitTable[((bbWork & -bbWork) * 0x218a392cd3d5dbf) >> 58]) );
            bbWork &= (bbWork-1); 
            piece = ( ((board[0]>>pos) &1) + 2*((board[1]>>pos) &1) + 4*((board[2]>>pos) &1) + 8*((board[3]>>pos) &1) )>>1;
            tmpscore+= EvalSfThreatBonus[ROOK*7+piece];
        }        
        bbWork = bbTemp & bbAttacks[QUEEN-1]; // enemy attacked by our queens
        // each enemy piece
        while (bbWork) {
            // pop 1st bit
            pos     = ((Square)(BitTable[((bbWork & -bbWork) * 0x218a392cd3d5dbf) >> 58]) );
            bbWork &= (bbWork-1); 
            piece = ( ((board[0]>>pos) &1) + 2*((board[1]>>pos) &1) + 4*((board[2]>>pos) &1) + 8*((board[3]>>pos) &1) )>>1;
            tmpscore+= EvalSfThreatBonus[QUEEN*7+piece];
        }        

        score+= tmpscore;
    
        // evaluate threats black
        tmpscore = 0;
        // enemy minor piece not defended?
        bbTemp = (board[0]^bbBlockers) & ( (~board[1] & board[2] & ~board[3]) | (~board[1] & ~board[2] & board[3]) ); // knights n bishops
        bbTemp&= bbAttacksW;
        tmpscore+= (!bbTemp)? UndefendedMinorPenalty : 0;
        // Enemy pieces not defended by a pawn and under our attack
        bbTemp = (board[0]^bbBlockers) & ~bbAttacks[0] & bbAttacksB;
        bbTemp^= ( board[1] & board[2] & ~board[3]); // except kings
        bbWork = bbTemp & bbAttacks[6+KNIGHT-1]; // enemy attacked by our knights
        // each enemy piece
        while (bbWork) {
            // pop 1st bit
            pos     = ((Square)(BitTable[((bbWork & -bbWork) * 0x218a392cd3d5dbf) >> 58]) );
            bbWork &= (bbWork-1); 
            piece = ( ((board[0]>>pos) &1) + 2*((board[1]>>pos) &1) + 4*((board[2]>>pos) &1) + 8*((board[3]>>pos) &1) )>>1;
            tmpscore+= EvalSfThreatBonus[KNIGHT*7+piece];
        }        
        bbWork = bbTemp & bbAttacks[6+BISHOP-1]; // enemy attacked by our bishops
        // each enemy piece
        while (bbWork) {
            // pop 1st bit
            pos     = ((Square)(BitTable[((bbWork & -bbWork) * 0x218a392cd3d5dbf) >> 58]) );
            bbWork &= (bbWork-1); 
            piece = ( ((board[0]>>pos) &1) + 2*((board[1]>>pos) &1) + 4*((board[2]>>pos) &1) + 8*((board[3]>>pos) &1) )>>1;
            tmpscore+= EvalSfThreatBonus[BISHOP*7+piece];
        }        
        bbWork = bbTemp & bbAttacks[6+ROOK-1]; // enemy attacked by our rooks
        // each enemy piece
        while (bbWork) {
            // pop 1st bit
            pos     = ((Square)(BitTable[((bbWork & -bbWork) * 0x218a392cd3d5dbf) >> 58]) );
            bbWork &= (bbWork-1); 
            piece = ( ((board[0]>>pos) &1) + 2*((board[1]>>pos) &1) + 4*((board[2]>>pos) &1) + 8*((board[3]>>pos) &1) )>>1;
            tmpscore+= EvalSfThreatBonus[ROOK*7+piece];
        }        
        bbWork = bbTemp & bbAttacks[6+QUEEN-1]; // enemy attacked by our queens
        // each enemy piece
        while (bbWork) {
            // pop 1st bit
            pos     = ((Square)(BitTable[((bbWork & -bbWork) * 0x218a392cd3d5dbf) >> 58]) );
            bbWork &= (bbWork-1); 
            piece = ( ((board[0]>>pos) &1) + 2*((board[1]>>pos) &1) + 4*((board[2]>>pos) &1) + 8*((board[3]>>pos) &1) )>>1;
            tmpscore+= EvalSfThreatBonus[QUEEN*7+piece];
        }        

        score-= tmpscore;

        // get plain material wo pawns for game phase decision
        tmpscore = 0;
        // except pawns
        bbWork    = bbBlockers ^ (board[1] & ~board[2] & ~board[3]);
        // each piece
        while (bbWork) {
            // pop 1st bit
            pos     = ((Square)(BitTable[((bbWork & -bbWork) * 0x218a392cd3d5dbf) >> 58]) );
            bbWork &= (bbWork-1); 
            piece = ( ((board[0]>>pos) &1) + 2*((board[1]>>pos) &1) + 4*((board[2]>>pos) &1) + 8*((board[3]>>pos) &1) )>>1;
            // Wood Count
            tmpscore+= getScore(EvalSfWood[piece], MIDGAME);
        }
        // game phase
        kic = (S32)((tmpscore >= MidgameLimit)? MIDGAME : (tmpscore <= EndgameLimit)? ENDGAME : (((tmpscore - EndgameLimit) * 128) / (MidgameLimit - EndgameLimit) ));

        // Interpolate Score
//        score = (Score)( (((getScore(score, MIDGAME) * kic + getScore(score, ENDGAME) * 128 - kic) / 128) + GrainSize / 2) & ~(GrainSize - 1));
        score = (Score)( (((getScore(score, MIDGAME) * kic + getScore(score, ENDGAME) * 128 - kic) / 128)));


        // negamaxed scores
        score = (som == BLACK)? -score : score;
        // checkmate
        score = (rootkic==1&&k==0)?-INF+ply:score;
        // Stalemate
        score = (rootkic==0&&k==0&&(mode==EXPAND||mode==EVALLEAF))?0:score;

        // draw by 3 fold repetition detection
        j = 0;
        if ( qs == 0 && n > 0 && index > 0 ) {
            for (i=ply-4; i>=0;i-=2) {

                if (board[4] == global_HashHistory[pid*1024+i] ) {
                    j++;
                }
                if ( j >= 1 ) {
                    n       = 0;
                    score   = 0;
                    break;
                }
            }   
        }   

        // out of range
        if (sd >= max_depth ) {
            n = 0;
        }

        // switch to expand mode
        if (mode == EVALLEAF && n == 0)
            mode = EXPAND;

        global_pid_movecounter[pid*max_depth+sd] = n;

        // eval leaf node
        if (mode == MOVEUP && n == 0 ) {
            global_pid_ab_score[pid*max_depth*2+(sd)*2+ALPHA] = score;
            mode = MOVEDOWN;
        }

        // stand pat
        // return Beta
        if (mode == MOVEUP && qs == 1 && rootkic == 0 && score >= global_pid_ab_score[pid*max_depth*2+(sd)*2+BETA] ) {
//            global_pid_ab_score[pid*max_depth*2+(sd)*2+ALPHA] = global_pid_ab_score[pid*max_depth*2+(sd)*2+BETA]; // fail hard
            global_pid_ab_score[pid*max_depth*2+(sd)*2+ALPHA] = score; // fail soft
			mode = MOVEDOWN;
        }

        // delta pruning
        if (DELTAPRUNING == 1 && mode == MOVEUP && qs == 1 && rootkic == 0 && count_1s(board[0] | board[1] | board[2]) > 11 ) {
            if (score < global_pid_ab_score[pid*max_depth*2+(sd)*2+ALPHA] - (getScore(EvalSfWood[(((lastmove>>26)&0xF)>>1)],MIDGAME)+200) ) {
                n = 0;
                global_pid_movecounter[pid*max_depth+sd] = n;
    			mode = MOVEDOWN;
            }
        }

        // stand pat
        // set Alpha
        if (mode == MOVEUP && qs == 1 && rootkic == 0 ) {
            atom_max(&global_pid_ab_score[pid*max_depth*2+(sd)*2+ALPHA], score);
		}


        // Expand Node
        if (mode == EXPAND ) {

           // Expand Node Counter
            COUNTERS[totalThreads*1+pid]++;

            // create child nodes
            current = atom_add(board_stack_top,n);

            // expand only if we got enough memory
            if ( n > 0 && current+n >= max_nodes_to_expand )
                n = -1;

            board_stack = (index >= max_nodes_per_slot)? board_stack_2 : board_stack_1;

            if (n > 0 ) {

                for(i=0;i<n;i++) {

                    move = global_pid_moves[pid*max_depth*MAXLEGALMOVES+sd*MAXLEGALMOVES+i];
    
                    parent = (current+i);      

                    board_stack_tmp = (parent >= max_nodes_per_slot)? board_stack_2 : board_stack_1;
                
                    board_stack_tmp[(parent%max_nodes_per_slot)].move       = move;
                    board_stack_tmp[(parent%max_nodes_per_slot)].score      = -INF;
                    board_stack_tmp[(parent%max_nodes_per_slot)].visits     =  0;
                    board_stack_tmp[(parent%max_nodes_per_slot)].children   = -1;
                    board_stack_tmp[(parent%max_nodes_per_slot)].parent     = index;
                    board_stack_tmp[(parent%max_nodes_per_slot)].child      = -1;
                    board_stack_tmp[(parent%max_nodes_per_slot)].lock       = -1;
                }

                board_stack[(index%max_nodes_per_slot)].child = current;
                board_stack[(index%max_nodes_per_slot)].children = n;
                mode = BACKUPSCORE;
            }
            else if (n == 0) {
                board_stack[(index%max_nodes_per_slot)].score = score;
                board_stack[(index%max_nodes_per_slot)].children = n;
                mode = BACKUPSCORE;
            }
            else if (n < 0) {
                board_stack[(index%max_nodes_per_slot)].score = -INF;
                // release lock
                board_stack[(index%max_nodes_per_slot)].lock = -1;
                mode = INIT;
            }
        }

        if (mode == EVALLEAF) {

            sd = 0;

            // search extensions
            depth = ( SINGLEREPLYEXTENSION == 1 && n == 1 )?search_depth+1:search_depth;
            depth = ( CHECKSEARCHEXTENSION == 1 && rootkic==1 )?search_depth+1:search_depth;
            depth = ( PROMOSEARCHEXTENSION == 1 && (((lastmove>>18)&0xF)>>1) == PAWN && (RelativeRank((((lastmove>>18)&0xF)&0x1),(((lastmove>>6)&0x3F)>>3)) >= 6 ) )?search_depth+1:search_depth;
            depth = ( CASTLEEXTENSION == 1 && (((lastmove>>54)&0xF)>>1) == ROOK )? search_depth+1:search_depth;
            depth = ( SILENTEXTENSION == 1 && silent == 1)? search_depth+1:search_depth;

            global_pid_todoindex[pid*max_depth+sd] = 0;

            // set init Alpha Beta values
            global_pid_ab_score[pid*max_depth*2+0*2+ALPHA] = -INF;
            global_pid_ab_score[pid*max_depth*2+0*2+BETA]  =  INF;

            mode = MOVEUP;
        }

        if (mode == MOVEDOWN ) {

            // incl AlphaBeta Pruning
            while (global_pid_todoindex[pid*max_depth+sd] >= global_pid_movecounter[pid*max_depth+sd] || (  global_pid_ab_score[pid*max_depth*2+(sd)*2+ALPHA] >= global_pid_ab_score[pid*max_depth*2+(sd)*2+BETA] ) ) {

                // do negamax-scoring
                score = global_pid_ab_score[pid*max_depth*2+(sd)*2+ALPHA];
                if ( abs(score) != INF && sd > 0)
                    atom_max(&global_pid_ab_score[pid*max_depth*2+(sd-1)*2+ALPHA], -score);

                sd--;
                ply--;

                if (sd < 0)
                    break;

                move = global_pid_moves[pid*max_depth*MAXLEGALMOVES+sd*MAXLEGALMOVES+global_pid_todoindex[pid*max_depth+sd]-1];

                undomove(board, move);

                updateHash(board, move);

                // switch site to move
                som = SwitchSide(som);
            }
 
            mode = MOVEUP;
          
            if (sd < 0) {
                board_stack = (index >= max_nodes_per_slot)? board_stack_2 : board_stack_1;
                board_stack[(index%max_nodes_per_slot)].score =  global_pid_ab_score[pid*max_depth*2+0*2+ALPHA];
                mode = BACKUPSCORE;
			}
        }

        if (mode == MOVEUP ) {

            // AB Search Node Counter
            COUNTERS[totalThreads*2+pid]++;
            atom_inc(total_nodes_visited);

            move = global_pid_moves[pid*max_depth*MAXLEGALMOVES+sd*MAXLEGALMOVES+global_pid_todoindex[pid*max_depth+sd]];

            domove(board, move);

            updateHash(board, move);

            lastmove = move;

            // switch site to move
            som = SwitchSide(som);


            global_pid_todoindex[pid*max_depth+sd]++;

            sd++;
            ply++;

            global_HashHistory[pid*1024+ply] = board[4];

            global_pid_movecounter[pid*max_depth+sd] = 0;
            global_pid_todoindex[pid*max_depth+sd] = 0;

            // Get Alpha and Beta from prev depth
            global_pid_ab_score[pid*max_depth*2+sd*2+ALPHA] = -global_pid_ab_score[pid*max_depth*2+(sd-1)*2+BETA];
            global_pid_ab_score[pid*max_depth*2+sd*2+BETA]  = -global_pid_ab_score[pid*max_depth*2+(sd-1)*2+ALPHA];

            continue;
        }
  
        if (mode == BACKUPSCORE) {

            mode = INIT;
            board_stack = (index >= max_nodes_per_slot)? board_stack_2 : board_stack_1;
            parent = board_stack[(index%max_nodes_per_slot)].parent;


            // backup score
            while( parent >= 0 ) {

                score = -INF;
                board_stack = (parent >= max_nodes_per_slot)? board_stack_2 : board_stack_1;
                j = board_stack[(parent%max_nodes_per_slot)].children;

                for(i=0;i<j;i++) {


                    child = board_stack[(parent%max_nodes_per_slot)].child + i;
                    board_stack_tmp = (child >= max_nodes_per_slot)? board_stack_2 : board_stack_1;

                    tmpscore = -board_stack_tmp[(child%max_nodes_per_slot)].score;

                    if ( abs(tmpscore) == INF ) { // skip unexplored 
                        score = -INF;
                        break;
                    }
                    if (tmpscore > score) {
                        score = tmpscore;
                    }
                }


                if ( abs(score) != INF ) {
                    tmpscore = atom_xchg(&board_stack[(parent%max_nodes_per_slot)].score, score);
                    if (parent == 0 && score > tmpscore)
                        COUNTERS[totalThreads*7+0] = (ply-ply_init)+1;
                }
                else
                    break;

                parent = board_stack[(parent%max_nodes_per_slot)].parent;
            }
            // release lock
            board_stack = (index >= max_nodes_per_slot)? board_stack_2 : board_stack_1;
            board_stack[(index%max_nodes_per_slot)].lock = -1;
        }
    } 
        
    // return to host
    COUNTERS[totalThreads*5+0] = *global_plyreached;
    COUNTERS[totalThreads*6+0] = (*board_stack_top >= max_nodes_to_expand)? 1 : 0;


}
